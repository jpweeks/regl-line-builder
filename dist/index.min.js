!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("gl-matrix")):"function"==typeof define&&define.amd?define(["exports","gl-matrix"],t):t(e.REGLLineBuilder={},e.glMatrix)}(this,function(e,t){"use strict";function r(e,t){var r=parseInt(t.replace(/^#/,""),16),n=Math.floor(r);e[0]=(n>>16&255)/255,e[1]=(n>>8&255)/255,e[2]=(255&n)/255}function n(e,t,r){return Math.max(Math.min(e,r),t)}function i(e){return function(){var t=Object.create(e.prototype);return e.apply(t,arguments),t}}function s(e,t,r){t.create=i(t),e&&(t.prototype=Object.create(e.prototype)),t.prototype.constructor=t,Object.assign(t.prototype,r)}function o(){this.offset=0,this.count=0,this.totalLength=0,this.isClosed=!1}function a(e,t){var r=t||{};r.dimensions=n(r.dimensions||2,2,3),r.bufferSize=r.bufferSize||1024,this.context=this.createContext(e),this.state=this.createState(r),this.resources=this.createResources(),this.attributes=this.createAttributes(),this.draw=this.createDrawCommand(r)}var c={frag:"precision highp float;\n#define GLSLIFY 1\nuniform vec4 tint;\nvarying vec4 vColor;\nvarying vec2 vUD;\n\nvoid main() {\n  gl_FragColor = vColor * tint;\n}\n",vert:"precision highp float;\n#define GLSLIFY 1\n\n// Based on WebGL lines demo\n// (c) 2015 Matt DesLauriers. MIT License\n// https://github.com/mattdesl/webgl-lines/\n\n// TODO: Maybe make separate package to make reuse with custom shaders easier?\n// TODO: Maybe use struct to pass some of this data?\nvec2 computeMiterOffset (\n  mat4 projection_0,\n  int adjustProjectedThickness_0,\n  float aspect_0,\n  float thickness_0,\n  float miterLimit_0,\n  vec4 prevProjected_0,\n  vec4 currProjected_0,\n  vec4 nextProjected_0\n) {\n  vec2 aspectVec = vec2(aspect_0, 1.0);\n\n  // get 2D screen space with W divide and aspect correction\n  vec2 prevScreen = prevProjected_0.xy / prevProjected_0.w * aspectVec;\n  vec2 currScreen = currProjected_0.xy / currProjected_0.w * aspectVec;\n  vec2 nextScreen = nextProjected_0.xy / nextProjected_0.w * aspectVec;\n\n  float thicknessScale = 1.0;\n  if (adjustProjectedThickness_0 == 1) {\n    vec4 singlePixelProjected = projection_0 * vec4(2.0, 0.0, 0.0, 1.0);\n    vec2 singlePixel = singlePixelProjected.xy / singlePixelProjected.w * aspectVec;\n    thicknessScale = singlePixel.x;\n  }\n\n  vec2 dir = vec2(0.0);\n  float len = thickness_0 * thicknessScale;\n\n  // starting point uses (next - current)\n  if (currScreen == prevScreen) {\n    dir = normalize(nextScreen - currScreen);\n  }\n  // ending point uses (current - previous)\n  else if (currScreen == nextScreen) {\n    dir = normalize(currScreen - prevScreen);\n  }\n  // somewhere in middle, needs a join\n  else {\n    // get directions from (C - B) and (B - A)\n    vec2 dirA = normalize((currScreen - prevScreen));\n    if (int(miterLimit_0) == -1) {\n      dir = dirA;\n    } else {\n      vec2 dirB = normalize((nextScreen - currScreen));\n      // now compute the miter join normal and length\n      vec2 tangent = normalize(dirA + dirB);\n      vec2 perp = vec2(-dirA.y, dirA.x);\n      vec2 miter = vec2(-tangent.y, tangent.x);\n      dir = tangent;\n      len /= dot(miter, perp);\n    }\n  }\n\n  return vec2(-dir.y, dir.x) *\n    clamp(len, 0.0, miterLimit_0 * thicknessScale) / aspectVec;\n}\n\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\nuniform float aspect;\nuniform int adjustProjectedThickness;\n\nuniform float thickness;\nuniform float miterLimit;\n\n#ifdef DIMENSIONS_3\nattribute vec3 prevPosition;\nattribute vec3 currPosition;\nattribute vec3 nextPosition;\n#else\nattribute vec2 prevPosition;\nattribute vec2 currPosition;\nattribute vec2 nextPosition;\n#endif\n\nattribute float offset;\nattribute vec4 color;\nattribute vec2 ud;\n\nvarying vec4 vColor;\nvarying vec2 vUD;\n\nvoid main() {\n  mat4 projViewModel = projection * view * model;\n\n#ifdef DIMENSIONS_3\n  vec4 prevProjected = projViewModel * vec4(prevPosition, 1.0);\n  vec4 currProjected = projViewModel * vec4(currPosition, 1.0);\n  vec4 nextProjected = projViewModel * vec4(nextPosition, 1.0);\n#else\n  vec4 prevProjected = projViewModel * vec4(prevPosition, 0.0, 1.0);\n  vec4 currProjected = projViewModel * vec4(currPosition, 0.0, 1.0);\n  vec4 nextProjected = projViewModel * vec4(nextPosition, 0.0, 1.0);\n#endif\n\n  vec2 miterOffset = computeMiterOffset(\n    projection, adjustProjectedThickness,\n    aspect, thickness, miterLimit,\n    prevProjected, currProjected, nextProjected);\n\n  vColor = color;\n  vUD = ud;\n\n  gl_Position = currProjected + vec4(miterOffset * offset, 0.0, 1.0);\n}\n"},f=Float32Array.BYTES_PER_ELEMENT,u=["beginPath","moveTo","lineTo","arc","closePath","stroke","strokeRect","setTransform","translate","scale","rotate","save","restore"],d=["globalAlpha","lineWidth","strokeStyle"],l=t.vec3.create();s(null,o,{}),s(null,a,{createContext:function(e){return{regl:e}},createState:function(e){return{is3d:3===e.dimensions,cursor:{vertex:0,element:0,quad:0,dimensions:e.dimensions,max:e.bufferSize},sync:{vertex:0},style:{color:[0,0,0,1],lineWidth:1,strokeStyle:"#000000"},transform:{isIdentity:!0,matrix:t.mat4.create()},activePath:null,prevPosition:t.vec3.create(),saveStack:[],scratchPath:o.create()}},createResources:function(){var e=this.context.regl,t=this.state.cursor,r=this.createResourceViews(t.max,t.dimensions),n=e.buffer({usage:"dynamic",type:"float",data:r.position}),i=e.buffer({usage:"dynamic",type:"float",data:r.offset}),s=e.buffer({usage:"dynamic",type:"float",data:r.color}),o=e.buffer({usage:"dynamic",type:"float",data:r.ud}),a=e.elements({usage:"dynamic",primitive:"triangles",data:r.elements});return{position:{view:r.position,buffer:n},offset:{view:r.offset,buffer:i},color:{view:r.color,buffer:s},ud:{view:r.ud,buffer:o},elements:{view:r.elements,buffer:a}}},createResourceViews:function(e,t){var r=this.getElementsCtor(e);return{position:new Float32Array(e*t*2),offset:new Float32Array(2*e),color:new Float32Array(4*e*2),ud:new Float32Array(2*e*3),elements:new r(4*e)}},getElementsCtor(e){var t=4*e*2>65536,r=this.context.regl.hasExtension("OES_element_index_uint");if(t&&!r)throw new Error("bufferSize is too big for Uint16Array, please enable OES_element_index_uint extension.");return t&&r?Uint32Array:Uint16Array},createAttributes:function(){var e=this.resources,t=this.state.cursor.dimensions,r=e.position,n=e.color,i=e.ud,s=e.offset;return{prevPosition:{buffer:r.buffer,offset:0,stride:f*t},currPosition:{buffer:r.buffer,offset:f*t*2,stride:f*t},nextPosition:{buffer:r.buffer,offset:f*t*4,stride:f*t},offset:s.buffer,ud:i.buffer,color:n.buffer}},combineDrawArgs:function(e,t){var r=Object.assign({},e);return Object.keys(t).forEach(function(n){r[n]="uniforms"===n||"attributes"===n?Object.assign({},e[n],t[n]):t[n]}),r},createDrawCommand:function(e){var t=this.attributes,r=this.context.regl,n=this.resources,i=this.state,s={aspect:function(e,t){return e.viewportWidth/e.viewportHeight},thickness:r.prop("thickness"),miterLimit:r.prop("miterLimit"),adjustProjectedThickness:function(e,t){return!0===t.adjustProjectedThickness?1:0},model:r.prop("model"),tint:r.prop("tint")},o={vert:c.vert,frag:c.frag,uniforms:s,attributes:t,elements:n.elements.buffer,count:function(){return 6*i.cursor.quad},depth:{enable:!0},cull:{enable:!0,face:"back"},blend:{enable:!0,equation:"add",func:{src:"src alpha",dst:"one minus src alpha"}}},a=e.drawArgs?this.combineDrawArgs(o,e.drawArgs):o;if(i.is3d){a.vert="#define DIMENSIONS_3\n"+a.vert,a.frag="#define DIMENSIONS_3\n"+a.frag}var f=r(a);return function(e){return i.sync.vertex<i.cursor.vertex&&(this.syncResourceBuffers(),i.sync.vertex=i.cursor.vertex),f(e)}.bind(this)},syncResourceBuffers:function(){var e=this.resources,t=e.position,r=e.offset,n=e.color,i=e.ud,s=e.elements;t.buffer.subdata(t.view),r.buffer.subdata(r.view),n.buffer.subdata(n.view),i.buffer.subdata(i.view),s.buffer.subdata(s.view)},getContext:function(e){var t=this,r=this.state,n={},i=this["methods"+(e||"2d")],s=this,o=this.accessors;return u.forEach(function(e){var r=i[e]||s[e];r&&(n[e]=r.bind(t))}),d.forEach(function(e){var t=o[e];Object.defineProperty(n,e,t(r))}),n},resize:function(e){var t=this.state.cursor,r=this.resources,n=this.createResourceViews(e,t.dimensions);t.max=e,r.position.view=n.position,r.position.buffer({data:n.position}),r.offset.view=n.offset,r.offset.buffer({data:n.offset}),r.color.view=n.color,r.color.buffer({data:n.color}),r.ud.view=n.ud,r.ud.buffer({data:n.ud}),r.elements.view=n.elements,r.elements.buffer({data:n.elements})},reset:function(){var e=this.state,r=e.is3d,n=e.cursor,i=e.sync,s=e.style,o=e.transform;n.quad=0,n.element=0,n.vertex=0,i.vertex=0,s.lineWidth=1,s.color[0]=0,s.color[1]=0,s.color[2]=0,s.color[3]=1,o.isIdentity=!0,r?t.mat4.identity(o.matrix):t.mat2d.identity(o.matrix),e.activePath=null,e.saveStack.length=0},destroy:function(){var e=this.resources;e.position.buffer.destroy(),e.offset.buffer.destroy(),e.color.buffer.destroy(),e.ud.buffer.destroy(),e.elements.buffer.destroy()},save:function(){var e=this.state,r=e.is3d,n=e.style,i=e.transform;e.saveStack.push({style:{lineWidth:n.lineWidth,color:n.color.slice()},transform:{isIdentity:i.isIdentity,matrix:r?t.mat4.clone(i.matrix):t.mat2d.clone(i.matrix)}})},restore:function(){var e=this.state,t=e.style,r=e.transform,n=e.saveStack.pop(),i=n.style,s=n.transform;t.lineWidth=i.lineWidth,t.color=i.color,r.isIdentity=s.isIdentity,r.matrix=s.matrix},beginPath:function(){var e=this.state,t=e.activePath,r=t?t.offset+t.count:0,n=e.scratchPath;n.offset=r,n.count=0,n.totalLength=0,n.isClosed=!1,e.activePath=n},moveTo:function(e,r,n){var i=n||0,s=this.state,o=s.activePath,a=s.prevPosition,c=s.is3d,f=s.cursor,u=f.dimensions,d=s.style.color,l=.5*s.style.lineWidth,v=this.resources,m=v.position.view,h=v.offset.view,p=v.ud.view,x=v.color.view,y=this.transformInput(e,r,i),b=f.vertex*u*2,P=b+1,g=(f.vertex+1)*u*2,w=g+1;if(m[b]=m[b+u]=y[0],m[P]=m[P+u]=y[1],m[g]=m[g+u]=y[0],m[w]=m[w+u]=y[1],c){var j=b+2,S=g+2;m[j]=m[j+u]=y[2],m[S]=m[S+u]=y[2]}var k=2*f.vertex,_=2*(f.vertex+1);h[k+0]=l,h[k+1]=-l,h[_+0]=l,h[_+1]=-l;var I=2*f.vertex*2,M=I+1,T=2*(f.vertex+1)*2,A=T+1;p[I]=1,p[I+2]=-1,p[T]=1,p[T+2]=-1,p[M]=p[M+2]=0,p[A]=p[A+2]=0;var O=4*f.vertex*2,L=O+1,C=O+2,E=O+3,V=4*(f.vertex+1)*2,D=V+1,W=V+2,z=V+3;x[O]=x[O+4]=d[0],x[L]=x[L+4]=d[1],x[C]=x[C+4]=d[2],x[E]=x[E+4]=d[3],x[V]=x[V+4]=d[0],x[D]=x[D+4]=d[1],x[W]=x[W+4]=d[2],x[z]=x[z+4]=d[3],t.vec2.copy(a,y),o.count+=1,f.vertex+=2},lineTo:function(e,r,n){var i=n||0,s=this.state,o=s.activePath,a=s.prevPosition,c=s.is3d,f=s.cursor,u=f.dimensions,d=s.style.color,l=.5*s.style.lineWidth,v=this.resources,m=v.position.view,h=v.offset.view,p=v.color.view,x=v.ud.view,y=v.elements.view,b=this.transformInput(e,r,i),P=t.vec2.distance(a,b),g=o.totalLength+=P,w=f.vertex*u*2,j=w+1;if(m[w]=m[w+u]=b[0],m[j]=m[j+u]=b[1],c){var S=w+2;m[S]=m[S+u]=b[2]}var k=2*f.vertex;h[k]=l,h[k+1]=-l;var _=2*(f.vertex-1)*2,I=_+1;x[_]=1,x[_+2]=-1,x[I]=x[I+2]=g;var M=4*f.vertex*2,T=M+1,A=M+2,O=M+3;p[M]=p[M+4]=d[0],p[T]=p[T+4]=d[1],p[A]=p[A+4]=d[2],p[O]=p[O+4]=d[3];var L=6*f.quad,C=f.element,E=C+1,V=C+2,D=C+3;y[L+0]=C,y[L+1]=E,y[L+2]=V,y[L+3]=V,y[L+4]=E,y[L+5]=D,t.vec2.copy(a,b),o.count+=1,f.quad+=1,f.element+=2,f.vertex+=1},arc:function(e,t,r,n,i,s){for(var o=Math.abs(i-n),a=!0===s?-1:1,c=Math.ceil(o/(Math.PI/10)),f=0;f<c;f++){var u=n+f/(c-1)*o*a,d=e+Math.cos(u)*r,l=t+Math.sin(u)*r;0===f?this.moveTo(d,l):this.lineTo(d,l)}},closePath:function(){var e=this.state,t=e.activePath,r=e.cursor,n=r.dimensions,i=e.is3d,s=this.resources.position.view,o=(r.vertex-t.count)*n*2,a=s[o],c=s[o+1],f=i?s[o+2]:0;t.isClosed=!0,this.lineTo(a,c,f)},stroke:function(){var e=this.state,t=e.activePath,r=e.is3d,n=e.cursor,i=n.dimensions,s=this.resources,o=s.position.view,a=s.offset.view,c=s.ud.view,f=s.color.view,u=n.vertex-t.count,d=n.vertex-1,l=n.vertex,v=d*i*2,m=v+1,h=l*i*2,p=h+1;if(o[h]=o[h+i]=o[v],o[p]=o[p+i]=o[m],r){var x=h+2,y=v+2;o[x]=o[x+i]=o[y]}var b=2*d,P=2*l;a[P]=a[b],a[P+1]=a[b+1];var g=2*d*2+1,w=2*l*2,j=w+1;c[w]=1,c[w+2]=-1,c[j]=c[j+2]=c[g];var S=4*d*2,k=S+1,_=S+2,I=S+3,M=4*l*2,T=M+1,A=M+2,O=M+3;f[M]=f[M+4]=f[S],f[T]=f[T+4]=f[k],f[A]=f[A+4]=f[_],f[O]=f[O+4]=f[I],n.element+=6,n.vertex+=1,t.isClosed&&(this.copyPosition(u-1,d-1),this.copyPosition(l,u+1))},strokeRect:function(e,t,r,n){this.beginPath(),this.moveTo(e,t),this.lineTo(e+r,t),this.lineTo(e+r,t+n),this.lineTo(e,t+n),this.closePath(),this.stroke()},methods2d:{setTransform:function(e,r,n,i,s,o){var a=this.state.transform;t.mat2d.set(a.matrix,e,r,n,i,s,o),a.isIdentity=!1},translate:function(e,r){var n=this.state.transform,i=t.vec2.set(l,e,r);t.mat2d.translate(n.matrix,n.matrix,i),n.isIdentity=!1},scale:function(e,r){var n=this.state.transform,i=t.vec2.set(l,e,r);t.mat2d.scale(n.matrix,n.matrix,i),n.isIdentity=!1},rotate:function(e){var r=this.state.transform;t.mat2d.rotate(r.matrix,r.matrix,e),r.isIdentity=!1}},methods3d:{setTransform:function(e,r,n,i,s,o,a,c,f,u,d,l,v,m,h,p){var x=this.state.transform;t.mat4.set(x.matrix,e,r,n,i,s,o,a,c,f,u,d,l,v,m,h,p),x.isIdentity=!1},translate:function(e,r,n){var i=this.state.transform,s=t.vec3.set(l,e,r,n);t.mat4.translate(i.matrix,i.matrix,s),i.isIdentity=!1},scale:function(e,r,n){var i=this.state.transform,s=t.vec3.set(l,e,r,n);t.mat4.scale(i.matrix,i.matrix,s),i.isIdentity=!1},rotate:function(e,r){var n=this.state.transform;switch(r){case"x":t.mat4.rotateX(n.matrix,n.matrix,e);break;case"y":t.mat4.rotateY(n.matrix,n.matrix,e);break;case"z":t.mat4.rotateZ(n.matrix,n.matrix,e);break;default:t.mat4.rotate(n.matrix,n.matrix,e,r)}n.isIdentity=!1}},accessors:{lineWidth:function(e){return{get:function(){return e.style.lineWidth},set:function(t){return e.style.lineWidth=t,t}}},globalAlpha:function(e){return{get:function(){return e.style.color[3]},set:function(t){return e.style.color[3]=t,t}}},strokeStyle:function(e){return{get:function(){return e.style.strokeStyle},set:function(t){return r(e.style.color,t),e.style.strokeStyle=t,t}}}},transformInput:function(e,r,n){var i,s=n||0,o=this.state,a=o.is3d,c=o.activePath,f=o.transform;return a?(i=t.vec3.set(l,e,r,s),f.isIdentity||c.isClosed||t.vec3.transformMat4(i,i,f.matrix)):(i=t.vec2.set(l,e,r),f.isIdentity||c.isClosed||t.vec2.transformMat2d(i,i,f.matrix)),i},copyPosition:function(e,t){var r=this.state,n=r.is3d,i=r.cursor.dimensions,s=this.resources.position.view,o=e*i*2,a=o+1,c=t*i*2,f=c+1;if(s[o]=s[o+i]=s[c],s[a]=s[a+i]=s[f],n){var u=o+2,d=c+2;s[u]=s[u+i]=s[d]}}}),e.LineBuilder=a,e.line=c,Object.defineProperty(e,"__esModule",{value:!0})});
