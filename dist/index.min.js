!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.REGLLineBuilder={})}(this,function(e){"use strict";function t(){let e=new _(6);return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e}function r(e){let t=new _(6);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t}function n(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e}function i(e,t,r,n,i,o,s){return e[0]=t,e[1]=r,e[2]=n,e[3]=i,e[4]=o,e[5]=s,e}function o(e,t,r){let n=t[0],i=t[1],o=t[2],s=t[3],a=t[4],c=t[5],u=Math.sin(r),f=Math.cos(r);return e[0]=n*f+o*u,e[1]=i*f+s*u,e[2]=n*-u+o*f,e[3]=i*-u+s*f,e[4]=a,e[5]=c,e}function s(e,t,r){let n=t[0],i=t[1],o=t[2],s=t[3],a=t[4],c=t[5],u=r[0],f=r[1];return e[0]=n*u,e[1]=i*u,e[2]=o*f,e[3]=s*f,e[4]=a,e[5]=c,e}function a(e,t,r){let n=t[0],i=t[1],o=t[2],s=t[3],a=t[4],c=t[5],u=r[0],f=r[1];return e[0]=n,e[1]=i,e[2]=o,e[3]=s,e[4]=n*u+o*f+a,e[5]=i*u+s*f+c,e}function c(){let e=new _(9);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function u(){let e=new _(3);return e[0]=0,e[1]=0,e[2]=0,e}function f(e,t,r){let n=new _(3);return n[0]=e,n[1]=t,n[2]=r,n}function l(e,t){let r=t[0],n=t[1],i=t[2],o=r*r+n*n+i*i;return o>0&&(o=1/Math.sqrt(o),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o),e}function v(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function d(e,t,r){let n=t[0],i=t[1],o=t[2],s=r[0],a=r[1],c=r[2];return e[0]=i*c-o*a,e[1]=o*s-n*c,e[2]=n*a-i*s,e}function h(){let e=new _(4);return e[0]=0,e[1]=0,e[2]=0,e[3]=0,e}function m(){let e=new _(4);return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e}function p(e,t,r){r*=.5;let n=Math.sin(r);return e[0]=n*t[0],e[1]=n*t[1],e[2]=n*t[2],e[3]=Math.cos(r),e}function y(e,t,r,n){let i,o,s,a,c,u=t[0],f=t[1],l=t[2],v=t[3],d=r[0],h=r[1],m=r[2],p=r[3];return(o=u*d+f*h+l*m+v*p)<0&&(o=-o,d=-d,h=-h,m=-m,p=-p),1-o>1e-6?(i=Math.acos(o),s=Math.sin(i),a=Math.sin((1-n)*i)/s,c=Math.sin(n*i)/s):(a=1-n,c=n),e[0]=a*u+c*d,e[1]=a*f+c*h,e[2]=a*l+c*m,e[3]=a*v+c*p,e}function x(e,t){let r,n=t[0]+t[4]+t[8];if(n>0)r=Math.sqrt(n+1),e[3]=.5*r,r=.5/r,e[0]=(t[5]-t[7])*r,e[1]=(t[6]-t[2])*r,e[2]=(t[1]-t[3])*r;else{let n=0;t[4]>t[0]&&(n=1),t[8]>t[3*n+n]&&(n=2);let i=(n+1)%3,o=(n+2)%3;r=Math.sqrt(t[3*n+n]-t[3*i+i]-t[3*o+o]+1),e[n]=.5*r,r=.5/r,e[3]=(t[3*i+o]-t[3*o+i])*r,e[i]=(t[3*i+n]+t[3*n+i])*r,e[o]=(t[3*o+n]+t[3*n+o])*r}return e}function w(){let e=new _(2);return e[0]=0,e[1]=0,e}function b(e,t){return e[0]=t[0],e[1]=t[1],e}function g(e,t,r){return e[0]=t,e[1]=r,e}function P(e,t){var r=t[0]-e[0],n=t[1]-e[1];return Math.sqrt(r*r+n*n)}function M(e,t,r){var n=t[0],i=t[1];return e[0]=r[0]*n+r[2]*i+r[4],e[1]=r[1]*n+r[3]*i+r[5],e}function j(e,t){var r=parseInt(t.replace(/^#/,""),16),n=Math.floor(r);e[0]=(n>>16&255)/255,e[1]=(n>>8&255)/255,e[2]=(255&n)/255}function S(e){return function(){var t=Object.create(e.prototype);return e.apply(t,arguments),t}}function k(e){var t=!1;return function(){t||(t=!0,console.warn(e))}}function L(e,t){this.context=this.createContext(e),this.state=this.createState(t),this.resources=this.createResources(),this.attributes=this.createAttributes(),this.draw=this.createDrawCommand(t)}let _="undefined"!=typeof Float32Array?Float32Array:Array;const A=function(e){let t=e[0],r=e[1],n=e[2];return Math.sqrt(t*t+r*r+n*n)},I=(function(){let e=u()}(),function(){let e=h()}(),function(e,t){let r=t[0],n=t[1],i=t[2],o=t[3],s=r*r+n*n+i*i+o*o;return s>0&&(s=1/Math.sqrt(s),e[0]=r*s,e[1]=n*s,e[2]=i*s,e[3]=o*s),e});(function(){let e=u(),t=f(1,0,0),r=f(0,1,0)})(),function(){let e=m(),t=m()}(),function(){let e=c()}(),function(){let e=w()}();var T={frag:"precision highp float;\n#define GLSLIFY 1\nuniform vec4 tint;\nvarying vec4 vColor;\nvarying vec2 vUD;\n\nvoid main() {\n  gl_FragColor = vColor * tint;\n}\n",vert:"// Based on WebGL lines demo\n// (c) 2015 Matt DesLauriers. MIT License\n// https://github.com/mattdesl/webgl-lines/\n\nprecision highp float;\n#define GLSLIFY 1\n\n// TODO: Maybe make separate package to make reuse with custom shaders easier?\n// TODO: Maybe use struct to pass some of this data?\nvec2 computeMiterNormal (\n  float aspect_0,\n  float thickness_0,\n  float miterLimit_0,\n  vec4 prevProjected_0,\n  vec4 currProjected_0,\n  vec4 nextProjected_0\n) {\n  vec2 aspectVec = vec2(aspect_0, 1.0);\n\n  // get 2D screen space with W divide and aspect correction\n  vec2 prevScreen = prevProjected_0.xy / prevProjected_0.w * aspectVec;\n  vec2 currScreen = currProjected_0.xy / currProjected_0.w * aspectVec;\n  vec2 nextScreen = nextProjected_0.xy / nextProjected_0.w * aspectVec;\n\n  vec2 dir = vec2(0.0);\n  float len = thickness_0;\n\n  // starting point uses (next - current)\n  if (currScreen == prevScreen) {\n    dir = normalize(nextScreen - currScreen);\n  }\n  // ending point uses (current - previous)\n  else if (currScreen == nextScreen) {\n    dir = normalize(currScreen - prevScreen);\n  }\n  // somewhere in middle, needs a join\n  else {\n    // get directions from (C - B) and (B - A)\n    vec2 dirA = normalize((currScreen - prevScreen));\n    if (int(miterLimit_0) == -1) {\n      dir = dirA;\n    } else {\n      vec2 dirB = normalize((nextScreen - currScreen));\n      // now compute the miter join normal and length\n      vec2 tangent = normalize(dirA + dirB);\n      vec2 perp = vec2(-dirA.y, dirA.x);\n      vec2 miter = vec2(-tangent.y, tangent.x);\n      dir = tangent;\n      len /= dot(miter, perp);\n    }\n  }\n\n  return vec2(-dir.y, dir.x) *\n    clamp(len, 0.0, max(thickness_0, miterLimit_0)) / aspectVec;\n}\n\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\nuniform float aspect;\n\nuniform float thickness;\nuniform float miterLimit;\n\n// TODO: Enable compiling for 2 or 3 dimensional lines\nattribute vec2 prevPosition;\nattribute vec2 currPosition;\nattribute vec2 nextPosition;\n\nattribute float offset;\nattribute vec4 color;\nattribute vec2 ud;\n\nvarying vec4 vColor;\nvarying vec2 vUD;\n\nvoid main() {\n  mat4 projViewModel = projection * view * model;\n\n  vec4 prevProjected = projViewModel * vec4(prevPosition, 0.0, 1.0);\n  vec4 currProjected = projViewModel * vec4(currPosition, 0.0, 1.0);\n  vec4 nextProjected = projViewModel * vec4(nextPosition, 0.0, 1.0);\n\n  vec2 normal = computeMiterNormal(\n    aspect, thickness, miterLimit,\n    prevProjected, currProjected, nextProjected);\n\n  vColor = color;\n  vUD = ud;\n\n  gl_Position = currProjected + vec4(normal * offset, 0.0, 1.0);\n}\n"},D=Float32Array.BYTES_PER_ELEMENT,W=["beginPath","moveTo","lineTo","arc","closePath","stroke","strokeRect","setLineDash","setTransform","translate","scale","rotate","save","restore"],C=["globalAlpha","lineDashOffset","lineWidth","strokeStyle"],O=w();!function(e,t,r){t.create=S(t),e&&(t.prototype=Object.create(e.prototype)),t.prototype.constructor=t,Object.assign(t.prototype,r)}(null,L,{createContext:function(e){return{regl:e}},createState:function(e){return{cursor:{vertex:0,element:0,quad:0,stride:e.stride||2,max:e.bufferSize||1024},sync:{vertex:0},style:{color:[0,0,0,1],lineWidth:1,strokeStyle:"#000000"},transform:{isIdentity:!0,matrix:t()},activePath:null,prevPosition:w(),paths:[],saveStack:[]}},createResources:function(){var e=this.context.regl,t=this.state.cursor,r=this.createResourceViews(t.max,t.stride),n=e.buffer({usage:"dynamic",type:"float",data:r.position}),i=e.buffer({usage:"dynamic",type:"float",data:r.offset}),o=e.buffer({usage:"dynamic",type:"float",data:r.color}),s=e.buffer({usage:"dynamic",type:"float",data:r.ud}),a=e.elements({usage:"dynamic",type:"uint16",primitive:"triangles",data:r.elements});return{position:{view:r.position,buffer:n},offset:{view:r.offset,buffer:i},color:{view:r.color,buffer:o},ud:{view:r.ud,buffer:s},elements:{view:r.elements,buffer:a}}},createResourceViews:function(e,t){return{position:new Float32Array(e*t*2),offset:new Float32Array(2*e),color:new Float32Array(4*e*2),ud:new Float32Array(2*e*3),elements:new Uint16Array(4*e)}},createAttributes:function(){var e=this.resources,t=this.state.cursor.stride,r=e.position,n=e.color,i=e.ud,o=e.offset;return{prevPosition:{buffer:r.buffer,offset:0,stride:D*t},currPosition:{buffer:r.buffer,offset:D*t*2,stride:D*t},nextPosition:{buffer:r.buffer,offset:D*t*4,stride:D*t},offset:o.buffer,ud:i.buffer,color:n.buffer}},createDrawCommand:function(e){var t=this.attributes,r=this.context.regl,n=this.resources,i=this.state,o={aspect:function(e,t){return e.viewportWidth/e.viewportHeight},thickness:function(e,t){return t.thickness/(200*e.viewportHeight/e.viewportWidth)},miterLimit:function(e,t){return t.miterLimit/(200*e.viewportHeight/e.viewportWidth)},model:r.prop("model"),tint:r.prop("tint")},s=r({vert:e.vert||T.vert,frag:e.frag||T.frag,uniforms:o,attributes:t,elements:n.elements.buffer,count:function(){return 6*i.cursor.quad},depth:{enable:!1},blend:{enable:!0,equation:"add",func:{src:"src alpha",dst:"one minus src alpha"}}});return function(e){return i.sync.vertex<i.cursor.vertex&&(this.syncResourceBuffers(),i.sync.vertex=i.cursor.vertex),s(e)}.bind(this)},syncResourceBuffers:function(){var e=this.resources,t=e.position,r=e.offset,n=e.color,i=e.ud,o=e.elements;t.buffer.subdata(t.view,0),r.buffer.subdata(r.view,0),n.buffer.subdata(n.view,0),i.buffer.subdata(i.view,0),o.buffer.subdata(o.view,0)},getContext:function(){var e=this,t=this.state,r={};return W.forEach(function(t){r[t]=e[t].bind(e)}),C.forEach(function(n){var i=e[n];Object.defineProperty(r,n,i(t))}),r},resize:function(e){var t=this.state.cursor,r=this.resources,n=this.createResourceViews(e,t.stride);t.max=e,r.position.view=n.position,r.position.buffer({data:n.position}),r.offset.view=n.offset,r.offset.buffer({data:n.offset}),r.color.view=n.color,r.color.buffer({data:n.color}),r.ud.view=n.ud,r.ud.buffer({data:n.ud}),r.elements.view=n.elements,r.elements.buffer({data:n.elements})},reset:function(){var e=this.state,t=e.cursor,r=e.sync,i=e.style,o=e.transform;t.quad=0,t.element=0,t.vertex=0,r.vertex=0,i.lineWidth=1,i.color[0]=0,i.color[1]=0,i.color[2]=0,i.color[3]=1,o.isIdentity=!0,n(o.matrix),e.activePath=null,e.paths.length=0},save:function(){var e=this.state,t=e.style,n=e.transform;e.saveStack.push({style:{lineWidth:t.lineWidth,color:t.color.slice()},transform:{isIdentity:n.isIdentity,matrix:r(n.matrix)}})},restore:function(){var e=this.state,t=e.style,r=e.transform,n=e.saveStack.pop(),i=n.style,o=n.transform;t.lineWidth=i.lineWidth,t.color=i.color,r.isIdentity=o.isIdentity,r.matrix=o.matrix},beginPath:function(){var e=this.state,t=e.activePath,r={offset:t?t.offset+t.count:0,count:0,totalLength:0,isClosed:!1};e.activePath=r,e.paths.push(r)},moveTo:function(e,t){var r=this.state,n=r.activePath,i=r.prevPosition,o=r.cursor,s=o.stride,a=r.style.color,c=.5*r.style.lineWidth,u=this.resources,f=u.position.view,l=u.offset.view,v=u.ud.view,d=u.color.view,h=this.transformInput(e,t),m=o.vertex*s*2,p=m+1,y=(o.vertex+1)*s*2,x=y+1;f[m]=f[m+s]=h[0],f[p]=f[p+s]=h[1],f[y]=f[y+s]=h[0],f[x]=f[x+s]=h[1];var w=2*o.vertex,g=2*(o.vertex+1);l[w+0]=c,l[w+1]=-c,l[g+0]=c,l[g+1]=-c;var P=2*o.vertex*2,M=P+1,j=2*(o.vertex+1)*2,S=j+1;v[P]=1,v[P+2]=-1,v[j]=1,v[j+2]=-1,v[M]=v[M+2]=0,v[S]=v[S+2]=0;var k=4*o.vertex*2,L=k+1,_=k+2,A=k+3,I=4*(o.vertex+1)*2,T=I+1,D=I+2,W=I+3;d[k]=d[k+4]=a[0],d[L]=d[L+4]=a[1],d[_]=d[_+4]=a[2],d[A]=d[A+4]=a[3],d[I]=d[I+4]=a[0],d[T]=d[T+4]=a[1],d[D]=d[D+4]=a[2],d[W]=d[W+4]=a[3],b(i,h),n.count+=1,o.vertex+=2},lineTo:function(e,t){var r=this.state,n=r.activePath,i=r.prevPosition,o=r.cursor,s=o.stride,a=r.style.color,c=.5*r.style.lineWidth,u=this.resources,f=u.position.view,l=u.offset.view,v=u.color.view,d=u.ud.view,h=u.elements.view,m=this.transformInput(e,t),p=P(i,m),y=n.totalLength+=p,x=o.vertex*s*2,w=x+1;f[x]=f[x+s]=m[0],f[w]=f[w+s]=m[1];var g=2*o.vertex;l[g]=c,l[g+1]=-c;var M=2*(o.vertex-1)*2,j=M+1;d[M]=1,d[M+2]=-1,d[j]=d[j+2]=y;var S=4*o.vertex*2,k=S+1,L=S+2,_=S+3;v[S]=v[S+4]=a[0],v[k]=v[k+4]=a[1],v[L]=v[L+4]=a[2],v[_]=v[_+4]=a[3];var A=6*o.quad,I=o.element,T=I+1,D=I+2,W=I+3;h[A+0]=I,h[A+1]=T,h[A+2]=D,h[A+3]=D,h[A+4]=T,h[A+5]=W,b(i,m),n.count+=1,o.quad+=1,o.element+=2,o.vertex+=1},arc:function(e,t,r,n,i,o){for(var s=Math.abs(i-n),a=!0===o?-1:1,c=Math.ceil(s/(Math.PI/10)),u=0;u<c;u++){var f=n+u/(c-1)*s*a,l=e+Math.cos(f)*r,v=t+Math.sin(f)*r;0===u?this.moveTo(l,v):this.lineTo(l,v)}},closePath:function(){var e=this.state,t=e.activePath,r=e.cursor,n=r.stride,i=this.resources.position.view,o=(r.vertex-t.count)*n*2,s=o+1,a=i[o],c=i[s];t.isClosed=!0,this.lineTo(a,c)},copyPosition:function(e,t){var r=this.state.cursor.stride,n=this.resources.position.view,i=e*r*2,o=i+1,s=t*r*2,a=s+1;n[i]=n[i+r]=n[s],n[o]=n[o+r]=n[a]},stroke:function(){var e=this.state,t=e.activePath,r=e.cursor,n=r.stride,i=this.resources,o=i.position.view,s=i.offset.view,a=i.ud.view,c=i.color.view,u=r.vertex-t.count,f=r.vertex-1,l=r.vertex,v=f*n*2,d=v+1,h=l*n*2,m=h+1;o[h]=o[h+n]=o[v],o[m]=o[m+n]=o[d];var p=2*f,y=2*l;s[y]=s[p],s[y+1]=s[p+1];var x=2*f*2+1,w=2*l*2,b=w+1;a[w]=1,a[w+2]=-1,a[b]=a[b+2]=a[x];var g=4*f*2,P=g+1,M=g+2,j=g+3,S=4*l*2,k=S+1,L=S+2,_=S+3;c[S]=c[S+4]=c[g],c[k]=c[k+4]=c[P],c[L]=c[L+4]=c[M],c[_]=c[_+4]=c[j],r.element+=6,r.vertex+=1,t.isClosed&&(this.copyPosition(u-1,f-1),this.copyPosition(l,u+1))},strokeRect:function(e,t,r,n){this.beginPath(),this.moveTo(e,t),this.lineTo(e+r,t),this.lineTo(e+r,t+n),this.lineTo(e,t+n),this.closePath(),this.stroke()},lineWidth:function(e){return{get:function(){return e.style.lineWidth},set:function(t){return e.style.lineWidth=t,t}}},globalAlpha:function(e){return{get:function(){return e.style.color[3]},set:function(t){return e.style.color[3]=t,t}}},strokeStyle:function(e){return{get:function(){return e.style.strokeStyle},set:function(t){return j(e.style.color,t),e.style.strokeStyle=t,t}}},lineDashOffset:function(){return{get:k("lineDashOffset not implemented"),set:k("lineDashOffset not implemented")}},setLineDash:k("setLineDash not implemented"),setTransform:function(e,t,r,n,o,s){var a=this.state.transform;i(a.matrix,e,t,r,n,o,s),a.isIdentity=!1},translate:function(e,t){var r=this.state.transform,n=g(O,e,t);a(r.matrix,r.matrix,n),r.isIdentity=!1},scale:function(e,t){var r=this.state.transform,n=g(O,e,t);s(r.matrix,r.matrix,n),r.isIdentity=!1},rotate:function(e){var t=this.state.transform;o(t.matrix,t.matrix,e),t.isIdentity=!1},transformInput:function(e,t){var r=this.state.activePath,n=this.state.transform,i=g(O,e,t);return n.isIdentity||r.isClosed||M(i,i,n.matrix),i}}),e.LineBuilder=L,e.line=T,Object.defineProperty(e,"__esModule",{value:!0})});
