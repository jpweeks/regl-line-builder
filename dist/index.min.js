!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("gl-matrix")):"function"==typeof define&&define.amd?define(["exports","gl-matrix"],t):t(e.REGLLineBuilder={},e.glMatrix)}(this,function(e,t){"use strict";function r(e,t){var r=parseInt(t.replace(/^#/,""),16),n=Math.floor(r);e[0]=(n>>16&255)/255,e[1]=(n>>8&255)/255,e[2]=(255&n)/255}function n(e){return function(){var t=Object.create(e.prototype);return e.apply(t,arguments),t}}function i(e,t,r){t.create=n(t),e&&(t.prototype=Object.create(e.prototype)),t.prototype.constructor=t,Object.assign(t.prototype,r)}function o(e){var t=!1;return function(){t||(t=!0,console.warn(e))}}function s(){this.offset=0,this.count=0,this.totalLength=0,this.isClosed=!1}function c(e,t){this.context=this.createContext(e),this.state=this.createState(t),this.resources=this.createResources(),this.attributes=this.createAttributes(),this.draw=this.createDrawCommand(t)}var a={frag:"precision highp float;\n#define GLSLIFY 1\nuniform vec4 tint;\nvarying vec4 vColor;\nvarying vec2 vUD;\n\nvoid main() {\n  gl_FragColor = vColor * tint;\n}\n",vert:"precision highp float;\n#define GLSLIFY 1\n\n// Based on WebGL lines demo\n// (c) 2015 Matt DesLauriers. MIT License\n// https://github.com/mattdesl/webgl-lines/\n\n// TODO: Maybe make separate package to make reuse with custom shaders easier?\n// TODO: Maybe use struct to pass some of this data?\nvec2 computeMiterOffset (\n  mat4 projection_0,\n  int adjustProjectedThickness_0,\n  float aspect_0,\n  float thickness_0,\n  float miterLimit_0,\n  vec4 prevProjected_0,\n  vec4 currProjected_0,\n  vec4 nextProjected_0\n) {\n  vec2 aspectVec = vec2(aspect_0, 1.0);\n\n  // get 2D screen space with W divide and aspect correction\n  vec2 prevScreen = prevProjected_0.xy / prevProjected_0.w * aspectVec;\n  vec2 currScreen = currProjected_0.xy / currProjected_0.w * aspectVec;\n  vec2 nextScreen = nextProjected_0.xy / nextProjected_0.w * aspectVec;\n\n  float thicknessScale = 1.0;\n  if (adjustProjectedThickness_0 == 1) {\n    vec4 singlePixelProjected = projection_0 * vec4(2.0, 0.0, 0.0, 1.0);\n    vec2 singlePixel = singlePixelProjected.xy / singlePixelProjected.w * aspectVec;\n    thicknessScale = singlePixel.x;\n  }\n\n  vec2 dir = vec2(0.0);\n  float len = thickness_0 * thicknessScale;\n\n  // starting point uses (next - current)\n  if (currScreen == prevScreen) {\n    dir = normalize(nextScreen - currScreen);\n  }\n  // ending point uses (current - previous)\n  else if (currScreen == nextScreen) {\n    dir = normalize(currScreen - prevScreen);\n  }\n  // somewhere in middle, needs a join\n  else {\n    // get directions from (C - B) and (B - A)\n    vec2 dirA = normalize((currScreen - prevScreen));\n    if (int(miterLimit_0) == -1) {\n      dir = dirA;\n    } else {\n      vec2 dirB = normalize((nextScreen - currScreen));\n      // now compute the miter join normal and length\n      vec2 tangent = normalize(dirA + dirB);\n      vec2 perp = vec2(-dirA.y, dirA.x);\n      vec2 miter = vec2(-tangent.y, tangent.x);\n      dir = tangent;\n      len /= dot(miter, perp);\n    }\n  }\n\n  return vec2(-dir.y, dir.x) *\n    clamp(len, 0.0, miterLimit_0 * thicknessScale) / aspectVec;\n}\n\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\nuniform float aspect;\nuniform int adjustProjectedThickness;\n\nuniform float thickness;\nuniform float miterLimit;\n\n// TODO: Enable compiling for 2 or 3 dimensional lines\nattribute vec2 prevPosition;\nattribute vec2 currPosition;\nattribute vec2 nextPosition;\n\nattribute float offset;\nattribute vec4 color;\nattribute vec2 ud;\n\nvarying vec4 vColor;\nvarying vec2 vUD;\n\nvoid main() {\n  mat4 projViewModel = projection * view * model;\n\n  vec4 prevProjected = projViewModel * vec4(prevPosition, 0.0, 1.0);\n  vec4 currProjected = projViewModel * vec4(currPosition, 0.0, 1.0);\n  vec4 nextProjected = projViewModel * vec4(nextPosition, 0.0, 1.0);\n\n  vec2 miterOffset = computeMiterOffset(\n    projection, adjustProjectedThickness,\n    aspect, thickness, miterLimit,\n    prevProjected, currProjected, nextProjected);\n\n  vColor = color;\n  vUD = ud;\n\n  gl_Position = currProjected + vec4(miterOffset * offset, 0.0, 1.0);\n}\n"},u=Float32Array.BYTES_PER_ELEMENT,f=["beginPath","moveTo","lineTo","arc","closePath","stroke","strokeRect","setLineDash","setTransform","translate","scale","rotate","save","restore"],l=["globalAlpha","lineDashOffset","lineWidth","strokeStyle"],v=t.vec2.create();i(null,s,{}),i(null,c,{createContext:function(e){return{regl:e}},createState:function(e){return{cursor:{vertex:0,element:0,quad:0,stride:e.stride||2,max:e.bufferSize||1024},sync:{vertex:0},style:{color:[0,0,0,1],lineWidth:1,strokeStyle:"#000000"},transform:{isIdentity:!0,matrix:t.mat2d.create()},activePath:null,prevPosition:t.vec2.create(),saveStack:[],scratchPath:s.create()}},createResources:function(){var e=this.context.regl,t=this.state.cursor,r=this.createResourceViews(t.max,t.stride),n=e.buffer({usage:"dynamic",type:"float",data:r.position}),i=e.buffer({usage:"dynamic",type:"float",data:r.offset}),o=e.buffer({usage:"dynamic",type:"float",data:r.color}),s=e.buffer({usage:"dynamic",type:"float",data:r.ud}),c=e.elements({usage:"dynamic",type:"uint16",primitive:"triangles",data:r.elements});return{position:{view:r.position,buffer:n},offset:{view:r.offset,buffer:i},color:{view:r.color,buffer:o},ud:{view:r.ud,buffer:s},elements:{view:r.elements,buffer:c}}},createResourceViews:function(e,t){return{position:new Float32Array(e*t*2),offset:new Float32Array(2*e),color:new Float32Array(4*e*2),ud:new Float32Array(2*e*3),elements:new Uint16Array(4*e)}},createAttributes:function(){var e=this.resources,t=this.state.cursor.stride,r=e.position,n=e.color,i=e.ud,o=e.offset;return{prevPosition:{buffer:r.buffer,offset:0,stride:u*t},currPosition:{buffer:r.buffer,offset:u*t*2,stride:u*t},nextPosition:{buffer:r.buffer,offset:u*t*4,stride:u*t},offset:o.buffer,ud:i.buffer,color:n.buffer}},combineDrawArgs:function(e,t){var r=Object.assign({},e);return Object.keys(t).forEach(function(n){r[n]="uniforms"===n||"attributes"===n?Object.assign({},e[n],t[n]):t[n]}),r},createDrawCommand:function(e){var t=this.attributes,r=this.context.regl,n=this.resources,i=this.state,o={aspect:function(e,t){return e.viewportWidth/e.viewportHeight},thickness:r.prop("thickness"),miterLimit:r.prop("miterLimit"),adjustProjectedThickness:function(e,t){return!1===t.adjustProjectedThickness?0:1},model:r.prop("model"),tint:r.prop("tint")},s={vert:a.vert,frag:a.frag,uniforms:o,attributes:t,elements:n.elements.buffer,count:function(){return 6*i.cursor.quad},depth:{enable:!1},blend:{enable:!0,equation:"add",func:{src:"src alpha",dst:"one minus src alpha"}}},c=r(e.drawArgs?this.combineDrawArgs(s,e.drawArgs):s);return function(e){return i.sync.vertex<i.cursor.vertex&&(this.syncResourceBuffers(),i.sync.vertex=i.cursor.vertex),c(e)}.bind(this)},syncResourceBuffers:function(){var e=this.resources,t=e.position,r=e.offset,n=e.color,i=e.ud,o=e.elements;t.buffer.subdata(t.view),r.buffer.subdata(r.view),n.buffer.subdata(n.view),i.buffer.subdata(i.view),o.buffer.subdata(o.view)},getContext:function(){var e=this,t=this.state,r={};return f.forEach(function(t){r[t]=e[t].bind(e)}),l.forEach(function(n){var i=e[n];Object.defineProperty(r,n,i(t))}),r},resize:function(e){var t=this.state.cursor,r=this.resources,n=this.createResourceViews(e,t.stride);t.max=e,r.position.view=n.position,r.position.buffer({data:n.position}),r.offset.view=n.offset,r.offset.buffer({data:n.offset}),r.color.view=n.color,r.color.buffer({data:n.color}),r.ud.view=n.ud,r.ud.buffer({data:n.ud}),r.elements.view=n.elements,r.elements.buffer({data:n.elements})},reset:function(){var e=this.state,r=e.cursor,n=e.sync,i=e.style,o=e.transform;r.quad=0,r.element=0,r.vertex=0,n.vertex=0,i.lineWidth=1,i.color[0]=0,i.color[1]=0,i.color[2]=0,i.color[3]=1,o.isIdentity=!0,t.mat2d.identity(o.matrix),e.activePath=null,e.saveStack.length=0},destroy:function(){var e=this.resources;e.position.buffer.destroy(),e.offset.buffer.destroy(),e.color.buffer.destroy(),e.ud.buffer.destroy(),e.elements.buffer.destroy()},save:function(){var e=this.state,r=e.style,n=e.transform;e.saveStack.push({style:{lineWidth:r.lineWidth,color:r.color.slice()},transform:{isIdentity:n.isIdentity,matrix:t.mat2d.clone(n.matrix)}})},restore:function(){var e=this.state,t=e.style,r=e.transform,n=e.saveStack.pop(),i=n.style,o=n.transform;t.lineWidth=i.lineWidth,t.color=i.color,r.isIdentity=o.isIdentity,r.matrix=o.matrix},beginPath:function(){var e=this.state,t=e.activePath,r=t?t.offset+t.count:0,n=e.scratchPath;n.offset=r,n.count=0,n.totalLength=0,n.isClosed=!1,e.activePath=n},moveTo:function(e,r){var n=this.state,i=n.activePath,o=n.prevPosition,s=n.cursor,c=s.stride,a=n.style.color,u=.5*n.style.lineWidth,f=this.resources,l=f.position.view,v=f.offset.view,d=f.ud.view,h=f.color.view,m=this.transformInput(e,r),p=s.vertex*c*2,y=p+1,x=(s.vertex+1)*c*2,b=x+1;l[p]=l[p+c]=m[0],l[y]=l[y+c]=m[1],l[x]=l[x+c]=m[0],l[b]=l[b+c]=m[1];var P=2*s.vertex,g=2*(s.vertex+1);v[P+0]=u,v[P+1]=-u,v[g+0]=u,v[g+1]=-u;var w=2*s.vertex*2,j=w+1,k=2*(s.vertex+1)*2,S=k+1;d[w]=1,d[w+2]=-1,d[k]=1,d[k+2]=-1,d[j]=d[j+2]=0,d[S]=d[S+2]=0;var _=4*s.vertex*2,T=_+1,L=_+2,O=_+3,A=4*(s.vertex+1)*2,M=A+1,D=A+2,I=A+3;h[_]=h[_+4]=a[0],h[T]=h[T+4]=a[1],h[L]=h[L+4]=a[2],h[O]=h[O+4]=a[3],h[A]=h[A+4]=a[0],h[M]=h[M+4]=a[1],h[D]=h[D+4]=a[2],h[I]=h[I+4]=a[3],t.vec2.copy(o,m),i.count+=1,s.vertex+=2},lineTo:function(e,r){var n=this.state,i=n.activePath,o=n.prevPosition,s=n.cursor,c=s.stride,a=n.style.color,u=.5*n.style.lineWidth,f=this.resources,l=f.position.view,v=f.offset.view,d=f.color.view,h=f.ud.view,m=f.elements.view,p=this.transformInput(e,r),y=t.vec2.distance(o,p),x=i.totalLength+=y,b=s.vertex*c*2,P=b+1;l[b]=l[b+c]=p[0],l[P]=l[P+c]=p[1];var g=2*s.vertex;v[g]=u,v[g+1]=-u;var w=2*(s.vertex-1)*2,j=w+1;h[w]=1,h[w+2]=-1,h[j]=h[j+2]=x;var k=4*s.vertex*2,S=k+1,_=k+2,T=k+3;d[k]=d[k+4]=a[0],d[S]=d[S+4]=a[1],d[_]=d[_+4]=a[2],d[T]=d[T+4]=a[3];var L=6*s.quad,O=s.element,A=O+1,M=O+2,D=O+3;m[L+0]=O,m[L+1]=A,m[L+2]=M,m[L+3]=M,m[L+4]=A,m[L+5]=D,t.vec2.copy(o,p),i.count+=1,s.quad+=1,s.element+=2,s.vertex+=1},arc:function(e,t,r,n,i,o){for(var s=Math.abs(i-n),c=!0===o?-1:1,a=Math.ceil(s/(Math.PI/10)),u=0;u<a;u++){var f=n+u/(a-1)*s*c,l=e+Math.cos(f)*r,v=t+Math.sin(f)*r;0===u?this.moveTo(l,v):this.lineTo(l,v)}},closePath:function(){var e=this.state,t=e.activePath,r=e.cursor,n=r.stride,i=this.resources.position.view,o=(r.vertex-t.count)*n*2,s=o+1,c=i[o],a=i[s];t.isClosed=!0,this.lineTo(c,a)},copyPosition:function(e,t){var r=this.state.cursor.stride,n=this.resources.position.view,i=e*r*2,o=i+1,s=t*r*2,c=s+1;n[i]=n[i+r]=n[s],n[o]=n[o+r]=n[c]},stroke:function(){var e=this.state,t=e.activePath,r=e.cursor,n=r.stride,i=this.resources,o=i.position.view,s=i.offset.view,c=i.ud.view,a=i.color.view,u=r.vertex-t.count,f=r.vertex-1,l=r.vertex,v=f*n*2,d=v+1,h=l*n*2,m=h+1;o[h]=o[h+n]=o[v],o[m]=o[m+n]=o[d];var p=2*f,y=2*l;s[y]=s[p],s[y+1]=s[p+1];var x=2*f*2+1,b=2*l*2,P=b+1;c[b]=1,c[b+2]=-1,c[P]=c[P+2]=c[x];var g=4*f*2,w=g+1,j=g+2,k=g+3,S=4*l*2,_=S+1,T=S+2,L=S+3;a[S]=a[S+4]=a[g],a[_]=a[_+4]=a[w],a[T]=a[T+4]=a[j],a[L]=a[L+4]=a[k],r.element+=6,r.vertex+=1,t.isClosed&&(this.copyPosition(u-1,f-1),this.copyPosition(l,u+1))},strokeRect:function(e,t,r,n){this.beginPath(),this.moveTo(e,t),this.lineTo(e+r,t),this.lineTo(e+r,t+n),this.lineTo(e,t+n),this.closePath(),this.stroke()},lineWidth:function(e){return{get:function(){return e.style.lineWidth},set:function(t){return e.style.lineWidth=t,t}}},globalAlpha:function(e){return{get:function(){return e.style.color[3]},set:function(t){return e.style.color[3]=t,t}}},strokeStyle:function(e){return{get:function(){return e.style.strokeStyle},set:function(t){return r(e.style.color,t),e.style.strokeStyle=t,t}}},lineDashOffset:function(){return{get:o("lineDashOffset not implemented"),set:o("lineDashOffset not implemented")}},setLineDash:o("setLineDash not implemented"),setTransform:function(e,r,n,i,o,s){var c=this.state.transform;t.mat2d.set(c.matrix,e,r,n,i,o,s),c.isIdentity=!1},translate:function(e,r){var n=this.state.transform,i=t.vec2.set(v,e,r);t.mat2d.translate(n.matrix,n.matrix,i),n.isIdentity=!1},scale:function(e,r){var n=this.state.transform,i=t.vec2.set(v,e,r);t.mat2d.scale(n.matrix,n.matrix,i),n.isIdentity=!1},rotate:function(e){var r=this.state.transform;t.mat2d.rotate(r.matrix,r.matrix,e),r.isIdentity=!1},transformInput:function(e,r){var n=this.state.activePath,i=this.state.transform,o=t.vec2.set(v,e,r);return i.isIdentity||n.isClosed||t.vec2.transformMat2d(o,o,i.matrix),o}}),e.LineBuilder=c,e.line=a,Object.defineProperty(e,"__esModule",{value:!0})});
