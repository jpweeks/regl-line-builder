!function e(t,r,n){function i(s,c){if(!r[s]){if(!t[s]){var a="function"==typeof require&&require;if(!c&&a)return a(s,!0);if(o)return o(s,!0);var u=new Error("Cannot find module '"+s+"'");throw u.code="MODULE_NOT_FOUND",u}var f=r[s]={exports:{}};t[s][0].call(f.exports,function(e){var r=t[s][1][e];return i(r||e)},f,f.exports,e,t,r,n)}return r[s].exports}for(var o="function"==typeof require&&require,s=0;s<n.length;s++)i(n[s]);return i}({1:[function(e,t,r){"use strict";function n(e){return e&&"object"==typeof e&&"default"in e?e.default:e}function i(e){return function(){var t=Object.create(e.prototype);return e.apply(t,arguments),t}}function o(e,t){this.context=this.createContext(e),this.state=this.createState(t),this.resources=this.createResources(),this.attributes=this.createAttributes(),this.draw=this.createDrawCommand()}Object.defineProperty(r,"__esModule",{value:!0});var s=n(e("gl-mat4/identity")),c=(n(e("glslify")),{frag:"precision highp float;\n#define GLSLIFY 1\nuniform vec3 color;\n\nvoid main() {\n  gl_FragColor = vec4(color, 1.0);\n}\n",vert:"// Based on WebGL lines demo\n// (c) 2015 Matt DesLauriers. MIT License\n// https://github.com/mattdesl/webgl-lines/\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\nuniform float aspect;\n\nuniform float thickness;\nuniform float miterLimit;\n\n// TODO: Enable compiling for 2 or 3 dimensional lines\nattribute vec2 prevPosition;\nattribute vec2 currPosition;\nattribute vec2 nextPosition;\n// attribute vec3 prevPosition;\n// attribute vec3 currPosition;\n// attribute vec3 nextPosition;\n\nattribute float offset;\n// attribute vec3 uv;\n\n// varying vec3 vUV;\n\nvoid main() {\n  vec2 aspectVec = vec2(aspect, 1.0);\n  mat4 projViewModel = projection * view * model;\n\n  // TODO: Refactor to import/export as standalone function\n  vec4 prevProjected = projViewModel * vec4(prevPosition, 0.0, 1.0);\n  vec4 currProjected = projViewModel * vec4(currPosition, 0.0, 1.0);\n  vec4 nextProjected = projViewModel * vec4(nextPosition, 0.0, 1.0);\n\n  // get 2D screen space with W divide and aspect correction\n  vec2 prevScreen = prevProjected.xy / prevProjected.w * aspectVec;\n  vec2 currScreen = currProjected.xy / currProjected.w * aspectVec;\n  vec2 nextScreen = nextProjected.xy / nextProjected.w * aspectVec;\n\n  vec2 dir = vec2(0.0);\n  float len = thickness;\n\n  // starting point uses (next - current)\n  if (currScreen == prevScreen) {\n    dir = normalize(nextScreen - currScreen);\n  }\n  // ending point uses (current - previous)\n  else if (currScreen == nextScreen) {\n    dir = normalize(currScreen - prevScreen);\n  }\n  // somewhere in middle, needs a join\n  else {\n    // get directions from (C - B) and (B - A)\n    vec2 dirA = normalize((currScreen - prevScreen));\n    if (int(miterLimit) == 0) {\n      dir = dirA;\n    } else {\n      vec2 dirB = normalize((nextScreen - currScreen));\n      // now compute the miter join normal and length\n      vec2 tangent = normalize(dirA + dirB);\n      vec2 perp = vec2(-dirA.y, dirA.x);\n      vec2 miter = vec2(-tangent.y, tangent.x);\n      dir = tangent;\n      len /= dot(miter, perp);\n    }\n  }\n\n  vec2 normal = vec2(-dir.y, dir.x) *\n    clamp(len, 0.0, max(thickness, miterLimit)) / aspectVec;\n\n  // vUV = uv;\n  gl_Position = currProjected + vec4(normal * offset, 0.0, 1.0);\n}\n"}),a=Float32Array.BYTES_PER_ELEMENT,u=Uint16Array.BYTES_PER_ELEMENT,f=["beginPath","moveTo","lineTo","arc","closePath","stroke"],v=["lineWidth"];!function(e,t,r){t.create=i(t),e&&(t.prototype=Object.create(e.prototype)),t.prototype.constructor=t,Object.assign(t.prototype,r)}(null,o,{createContext:function(e){return{regl:e}},createState:function(e){return{cursor:{vertex:0,element:0,quad:0,stride:e.stride,max:e.maxSize},sync:{vertex:0},style:{lineWidth:1},activePath:null,paths:[]}},createResources:function(){var e=this.context.regl,t=this.state.cursor,r=new Float32Array(t.max*t.stride*2),n=new Float32Array(2*t.max),i=new Uint16Array(4*t.max);return{position:{view:r,buffer:e.buffer({usage:"dynamic",type:"float",length:r.length*a})},offset:{view:n,buffer:e.buffer({usage:"dynamic",type:"float",length:n.length*a})},elements:{view:i,buffer:e.elements({usage:"dynamic",type:"uint16",primitive:"triangles",length:i.length*u})}}},createAttributes:function(){var e=this.state.cursor.stride,t=this.resources.position,r=this.resources.offset;return{prevPosition:{buffer:t.buffer,offset:0,stride:a*e},currPosition:{buffer:t.buffer,offset:a*e*2,stride:a*e},nextPosition:{buffer:t.buffer,offset:a*e*4,stride:a*e},offset:r.buffer}},createDrawCommand:function(){var e=this.attributes,t=this.context.regl,r=this.resources,n=this.state,i={model:s([]),aspect:function(e){return e.viewportWidth/e.viewportHeight},color:t.prop("color"),thickness:t.prop("thickness"),miterLimit:t.prop("miterLimit")},o=t({vert:c.vert,frag:c.frag,uniforms:i,attributes:e,elements:r.elements.buffer,count:function(){return 6*n.cursor.quad},depth:{enable:!1}});return function(e){return n.sync.vertex<n.cursor.vertex&&(this.syncResourceBuffers(),n.sync.vertex=n.cursor.vertex),o(e)}.bind(this)},syncResourceBuffers:function(){var e=this.resources.position,t=this.resources.offset,r=this.resources.elements;e.buffer.subdata(e.view,0),t.buffer.subdata(t.view,0),r.buffer.subdata(r.view,0)},getContext:function(){var e=this,t=this.state,r={};return f.forEach(function(t){r[t]=e[t].bind(e)}),v.forEach(function(n){var i=e[n];Object.defineProperty(r,n,i(t))}),r},resize:function(e){this.state.cursor.max=e},reset:function(){var e=this.state;e.cursor.quad=0,e.cursor.element=0,e.cursor.vertex=0,e.sync.vertex=0,e.style.lineWidth=1,e.activePath=null,e.paths=[]},beginPath:function(){var e=this.state,t=e.activePath,r={offset:t?t.offset+t.count:0,count:0,isClosed:!1};e.activePath=r,e.paths.push(r)},moveTo:function(e,t){var r=this.state,n=r.activePath,i=r.cursor,o=i.stride,s=.5*r.style.lineWidth,c=this.resources,a=c.position.view,u=c.offset.view,f=i.vertex*o*2,v=f+1,l=(i.vertex+1)*o*2,d=l+1;a[f]=a[f+o]=e,a[v]=a[v+o]=t,a[l]=a[l+o]=e,a[d]=a[d+o]=t;var h=2*i.vertex,p=2*(i.vertex+1);u[h+0]=s,u[h+1]=-s,u[p+0]=s,u[p+1]=-s,n.count+=1,i.vertex+=2},lineTo:function(e,t){var r=this.state,n=r.activePath,i=r.cursor,o=i.stride,s=.5*r.style.lineWidth,c=this.resources,a=c.position.view,u=c.offset.view,f=c.elements.view,v=i.vertex*o*2,l=v+1;a[v]=a[v+o]=e,a[l]=a[l+o]=t;var d=2*i.vertex;u[d]=s,u[d+1]=-s;var h=6*i.quad,p=i.element,m=p+1,x=p+2,y=p+3;f[h+0]=p,f[h+1]=m,f[h+2]=x,f[h+3]=x,f[h+4]=m,f[h+5]=y,n.count+=1,i.quad+=1,i.element+=2,i.vertex+=1},arc:function(e,t,r,n,i,o){for(var s=i-n,c=!0===o?-1:1,a=Math.ceil(s/(Math.PI/10)),u=0;u<a;u++){var f=n+u/(a-1)*s*c,v=e+Math.cos(f)*r,l=t+Math.sin(f)*r;0===u?this.moveTo(v,l):this.lineTo(v,l)}},closePath:function(){var e=this.state,t=e.activePath,r=e.cursor,n=r.stride,i=this.resources.position.view,o=(r.vertex-t.count)*n*2,s=o+1,c=i[o],a=i[s];this.lineTo(c,a),t.isClosed=!0},copyPosition:function(e,t){var r=this.state.cursor.stride,n=this.resources.position.view,i=e*r*2,o=i+1,s=t*r*2,c=s+1;n[i]=n[i+r]=n[s],n[o]=n[o+r]=n[c]},stroke:function(){var e=this.state,t=e.activePath,r=e.cursor,n=r.stride,i=this.resources,o=i.position.view,s=i.offset.view,c=r.vertex-t.count,a=r.vertex-1,u=r.vertex,f=a*n*2,v=f+1,l=u*n*2,d=l+1,h=2*a,p=2*u;o[l]=o[l+n]=o[f],o[d]=o[d+n]=o[v],s[p]=s[h],s[p+1]=s[h+1],r.element+=6,r.vertex+=1,t.isClosed&&(this.copyPosition(c-1,a-1),this.copyPosition(u,c+1))},lineWidth:function(e){return{get:function(){return e.style.lineWidth},set:function(t){return e.style.lineWidth=t,t}}}}),r.LineBuilder=o,r.line=c},{"gl-mat4/identity":2,glslify:3}],2:[function(e,t,r){t.exports=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}},{}],3:[function(e,t,r){t.exports=function(e){"string"==typeof e&&(e=[e]);for(var t=[].slice.call(arguments,1),r=[],n=0;n<e.length-1;n++)r.push(e[n],t[n]||"");return r.push(e[n]),r.join("")}},{}]},{},[1]);
