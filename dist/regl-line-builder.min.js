!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("gl-matrix"),require("earcut")):"function"==typeof define&&define.amd?define(["exports","gl-matrix","earcut"],t):t(e.REGLLineBuilder={},{vec2:e.vec2,vec3:e.vec3,mat2d:e.mat2d,mat4:e.mat4},e.earcut)}(this,function(e,t,r){"use strict";function i(e,t,r){t.create=function(e){return function(){var t=Object.create(e.prototype);return e.apply(t,arguments),t}}(t),e&&(t.prototype=Object.create(e.prototype)),t.prototype.constructor=t,Object.assign(t.prototype,r)}function n(e){this.dimensions=e.dimensions,this.offset=0,this.count=0,this.totalLength=0,this.isClosed=!1,this.points=[]}function o(e,t){var r=parseInt(t.replace(/^#/,""),16),i=Math.floor(r);e[0]=(i>>16&255)/255,e[1]=(i>>8&255)/255,e[2]=(255&i)/255}r=r&&r.hasOwnProperty("default")?r.default:r,i(null,n,{reset:function(){this.offset=0,this.count=0,this.totalLength=0,this.isClosed=!1},addPoint:function(e){var r=this.points,i=this.dimensions,n=r[this.count++];n||(n=2===i?t.vec2.create():t.vec3.create(),r.push(n)),2===i?t.vec2.copy(n,e):t.vec3.copy(n,e)}});var s={frag:"precision highp float;\n#define GLSLIFY 1\nuniform vec4 tint;\nvarying vec4 vColor;\nvarying vec2 vUD;\n\nvoid main() {\n  gl_FragColor = vColor * tint;\n}\n",vert:"precision highp float;\n#define GLSLIFY 1\n\n// Based on WebGL lines demo\n// (c) 2015 Matt DesLauriers. MIT License\n// https://github.com/mattdesl/webgl-lines/\n\n// TODO: Maybe make separate package to make reuse with custom shaders easier?\n// TODO: Maybe use struct to pass some of this data?\nvec2 computeMiterOffset (\n  mat4 projection_0,\n  int adjustProjectedThickness_0,\n  float aspect_0,\n  float thickness_0,\n  float miterLimit_0,\n  vec4 prevProjected_0,\n  vec4 currProjected_0,\n  vec4 nextProjected_0\n) {\n  vec2 aspectVec = vec2(aspect_0, 1.0);\n\n  // get 2D screen space with W divide and aspect correction\n  vec2 prevScreen = prevProjected_0.xy / prevProjected_0.w * aspectVec;\n  vec2 currScreen = currProjected_0.xy / currProjected_0.w * aspectVec;\n  vec2 nextScreen = nextProjected_0.xy / nextProjected_0.w * aspectVec;\n\n  float thicknessScale = 1.0;\n  if (adjustProjectedThickness_0 == 1) {\n    vec4 singlePixelProjected = projection_0 * vec4(2.0, 0.0, 0.0, 1.0);\n    vec2 singlePixel = singlePixelProjected.xy / singlePixelProjected.w * aspectVec;\n    thicknessScale = singlePixel.x;\n  }\n\n  vec2 dir = vec2(0.0);\n  float len = thickness_0 * thicknessScale;\n\n  // OPTIM: Improve equality checks\n  // starting point uses (next - current)\n  if (currScreen == prevScreen) {\n    dir = normalize(nextScreen - currScreen);\n  }\n  // ending point uses (current - previous)\n  else if (currScreen == nextScreen) {\n    dir = normalize(currScreen - prevScreen);\n  }\n  // somewhere in middle, needs a join\n  else {\n    // get directions from (C - B) and (B - A)\n    vec2 dirA = normalize((currScreen - prevScreen));\n    if (int(miterLimit_0) == -1) {\n      dir = dirA;\n    } else {\n      vec2 dirB = normalize((nextScreen - currScreen));\n      // now compute the miter join normal and length\n      vec2 tangent = normalize(dirA + dirB);\n      vec2 perp = vec2(-dirA.y, dirA.x);\n      vec2 miter = vec2(-tangent.y, tangent.x);\n      dir = tangent;\n      len /= dot(miter, perp);\n    }\n  }\n\n  return vec2(-dir.y, dir.x) *\n    clamp(len, 0.0, miterLimit_0 * thicknessScale) / aspectVec;\n}\n\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\nuniform float aspect;\nuniform int adjustProjectedThickness;\n\nuniform float thickness;\nuniform float miterLimit;\n\n#ifdef DIMENSIONS_3\nattribute vec3 prevPosition;\nattribute vec3 currPosition;\nattribute vec3 nextPosition;\n#else\nattribute vec2 prevPosition;\nattribute vec2 currPosition;\nattribute vec2 nextPosition;\n#endif\n\nattribute float offset;\nattribute vec4 color;\nattribute vec2 ud;\n\nvarying vec4 vColor;\nvarying vec2 vUD;\n\nvoid main() {\n  mat4 projViewModel = projection * view * model;\n\n#ifdef DIMENSIONS_3\n  vec4 prevProjected = projViewModel * vec4(prevPosition, 1.0);\n  vec4 currProjected = projViewModel * vec4(currPosition, 1.0);\n  vec4 nextProjected = projViewModel * vec4(nextPosition, 1.0);\n#else\n  vec4 prevProjected = projViewModel * vec4(prevPosition, 0.0, 1.0);\n  vec4 currProjected = projViewModel * vec4(currPosition, 0.0, 1.0);\n  vec4 nextProjected = projViewModel * vec4(nextPosition, 0.0, 1.0);\n#endif\n\n  vec2 miterOffset = computeMiterOffset(\n    projection, adjustProjectedThickness,\n    aspect, thickness, miterLimit,\n    prevProjected, currProjected, nextProjected);\n\n  vColor = color;\n  vUD = ud;\n\n  gl_Position = currProjected + vec4(miterOffset * offset, 0.0, 1.0);\n}\n"},a="precision highp float;\n#define GLSLIFY 1\nuniform vec4 tint;\nvarying vec4 vColor;\n\nvoid main() {\n  gl_FragColor = vColor * tint;\n}\n",c="precision highp float;\n#define GLSLIFY 1\n\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\n\n// #ifdef DIMENSIONS_3\n// attribute vec3 position;\n// #else\nattribute vec2 position;\n// #endif\n\nattribute vec4 color;\n\nvarying vec4 vColor;\n\nvoid main() {\n  mat4 projViewModel = projection * view * model;\n  vec4 posProjected = projViewModel * vec4(position, 0.0, 1.0);\n\n  vColor = color;\n\n  gl_Position = posProjected * vec4(0.5, 0.5, 0.0, 1.0);\n}\n",l=Float32Array.BYTES_PER_ELEMENT,f=["beginPath","moveTo","lineTo","arc","closePath","stroke","strokeRect","fill","setTransform","translate","scale","rotate","save","restore"],u=["globalAlpha","lineWidth","strokeStyle","fillStyle"],v=t.vec3.create();function d(e,t){var r,i,n,o=t||{};o.dimensions=(r=o.dimensions||2,i=2,n=3,Math.max(Math.min(r,n),i)),o.bufferSize=o.bufferSize||1024,this.context=this.createContext(e),this.state=this.createState(o),this.resources=this.createResources(),this.attributes=this.createAttributes(),this.draw=this.createDrawCommand(o)}i(null,d,{createContext:function(e){return{regl:e}},createState:function(e){var r=3===e.dimensions;return{is3d:r,cursor:{vertex:0,element:0,quad:0,fillVertex:0,fillElement:0,fillTri:0,dimensions:e.dimensions,max:e.bufferSize},sync:{vertex:0},style:{color:new Float32Array([0,0,0,1]),lineWidth:1,strokeStyle:"#000000",fillColor:new Float32Array([0,0,0,1]),fillStyle:"#000000"},transform:{isIdentity:!0,matrix:r?t.mat4.create():t.mat2d.create()},activePath:null,prevPosition:t.vec3.create(),saveStack:[],scratchPath:n.create({dimensions:e.dimensions})}},createResources:function(){var e=this.context.regl,t=this.state.cursor,r=this.createResourceViews(t.max,t.dimensions),i=e.buffer({usage:"dynamic",type:"float",data:r.position}),n=e.buffer({usage:"dynamic",type:"float",data:r.offset}),o=e.buffer({usage:"dynamic",type:"float",data:r.color}),s=e.buffer({usage:"dynamic",type:"float",data:r.ud}),a=e.elements({usage:"dynamic",primitive:"triangles",data:r.elements}),c=e.buffer({usage:"dynamic",type:"float",data:r.fillPosition}),l=e.buffer({usage:"dynamic",type:"float",data:r.fillColor}),f=e.elements({usage:"dynamic",primitive:"triangles",data:r.fillElements});return{position:{view:r.position,buffer:i},offset:{view:r.offset,buffer:n},color:{view:r.color,buffer:o},ud:{view:r.ud,buffer:s},elements:{view:r.elements,buffer:a},fillPosition:{view:r.fillPosition,buffer:c},fillColor:{view:r.fillColor,buffer:l},fillElements:{view:r.fillElements,buffer:f}}},createResourceViews:function(e,t){var r=this.getElementsCtor(e);return{position:new Float32Array(e*t*2),offset:new Float32Array(2*e),color:new Float32Array(4*e*2),ud:new Float32Array(2*e*3),elements:new r(4*e),fillPosition:new Float32Array(e*t),fillColor:new Float32Array(4*e),fillElements:new r(3*e)}},getElementsCtor(e){var t=4*e*2>65536,r=this.context.regl.hasExtension("OES_element_index_uint");if(t&&!r)throw new Error("bufferSize is too big for Uint16Array, please enable OES_element_index_uint extension.");return t&&r?Uint32Array:Uint16Array},createAttributes:function(){var e=this.resources,t=this.state.cursor.dimensions,r=e.position,i=e.color,n=e.ud,o=e.offset,s=e.fillPosition,a=e.fillColor;return{line:{prevPosition:{buffer:r.buffer,offset:0,stride:l*t},currPosition:{buffer:r.buffer,offset:l*t*2,stride:l*t},nextPosition:{buffer:r.buffer,offset:l*t*4,stride:l*t},offset:o.buffer,ud:n.buffer,color:i.buffer},fill:{position:s.buffer,color:a.buffer}}},combineDrawArgs:function(e,t){var r=Object.assign({},e);return Object.keys(t).forEach(function(i){r[i]="uniforms"===i||"attributes"===i?Object.assign({},e[i],t[i]):t[i]}),r},createDrawCommand:function(e){var t=this.attributes,r=this.context.regl,i=this.resources,n=this.state,o={line:{aspect:function(e,t){return e.viewportWidth/e.viewportHeight},thickness:r.prop("thickness"),miterLimit:r.prop("miterLimit"),adjustProjectedThickness:function(e,t){return!0===t.adjustProjectedThickness?1:0}},fill:{}},l={enable:!1},f={enable:!0,face:"back"},u={enable:!0,equation:"add",func:{src:"src alpha",dst:"one minus src alpha"}},v={uniforms:{model:r.prop("model"),tint:r.prop("tint")}},d={vert:s.vert,frag:s.frag,uniforms:o.line,attributes:t.line,elements:i.elements.buffer,count:function(){return 6*n.cursor.quad},depth:l,cull:f,blend:u},m=e.drawLineArgs?this.combineDrawArgs(d,e.drawLineArgs):d,h={vert:c,frag:a,uniforms:o.fill,attributes:t.fill,elements:i.fillElements.buffer,count:function(){return 3*n.cursor.fillTri},depth:l,cull:f,blend:u},p=e.drawFillArgs?this.combineDrawArgs(h,e.drawFillArgs):h;if(n.is3d){m.vert="#define DIMENSIONS_3\n"+m.vert,m.frag="#define DIMENSIONS_3\n"+m.frag}var y=r(v),x=r(m),b=r(p);return function(e){return n.sync.vertex<n.cursor.vertex&&(this.syncResourceBuffers(),n.sync.vertex=n.cursor.vertex),y(e,function(){b(e),x(e)})}.bind(this)},syncResourceBuffers:function(){var e=this.resources,t=e.position,r=e.offset,i=e.color,n=e.ud,o=e.elements,s=e.fillPosition,a=e.fillColor,c=e.fillElements;t.buffer.subdata(t.view),r.buffer.subdata(r.view),i.buffer.subdata(i.view),n.buffer.subdata(n.view),o.buffer.subdata(o.view),s.buffer.subdata(s.view),a.buffer.subdata(a.view),c.buffer.subdata(c.view)},getContext:function(e){var t=this,r=this.state,i={},n=this["methods"+(e||"2d")],o=this,s=this.accessors;return f.forEach(function(e){var r=n[e]||o[e];r&&(i[e]=r.bind(t))}),u.forEach(function(e){var t=s[e];Object.defineProperty(i,e,t(r))}),i},resize:function(e){var t=this.state.cursor,r=this.resources,i=this.createResourceViews(e,t.dimensions);t.max=e,Object.keys(i).forEach(function(e){r[e].view=i[e],r[e].buffer({data:i[e]})})},reset:function(){var e=this.state,r=e.is3d,i=e.cursor,n=e.sync,o=e.style,s=e.transform;i.vertex=0,i.element=0,i.quad=0,i.fillVertex=0,i.fillElement=0,i.fillTri=0,n.vertex=0,o.lineWidth=1,o.color[0]=0,o.color[1]=0,o.color[2]=0,o.color[3]=1,s.isIdentity=!0,r?t.mat4.identity(s.matrix):t.mat2d.identity(s.matrix),e.activePath=null,e.saveStack.length=0},destroy:function(){var e=this.resources;e.position.buffer.destroy(),e.offset.buffer.destroy(),e.color.buffer.destroy(),e.ud.buffer.destroy(),e.elements.buffer.destroy()},save:function(){var e=this.state,r=e.is3d,i=e.style,n=e.transform;e.saveStack.push({style:{lineWidth:i.lineWidth,color:i.color.slice()},transform:{isIdentity:n.isIdentity,matrix:r?t.mat4.clone(n.matrix):t.mat2d.clone(n.matrix)}})},restore:function(){var e=this.state,t=e.style,r=e.transform,i=e.saveStack.pop(),n=i.style,o=i.transform;t.lineWidth=n.lineWidth,t.color=n.color,r.isIdentity=o.isIdentity,r.matrix=o.matrix},beginPath:function(){var e=this.state,t=e.activePath,r=t?t.offset+t.count:0,i=e.scratchPath;i.reset(),i.offset=r,e.activePath=i},moveTo:function(e,r,i){var n=i||0,o=this.state,s=o.activePath,a=o.prevPosition,c=o.is3d,l=o.cursor,f=l.dimensions,u=o.style.color,v=.5*o.style.lineWidth,d=this.resources,m=d.position.view,h=d.offset.view,p=d.ud.view,y=d.color.view,x=this.transformInput(e,r,n),b=l.vertex*f*2,P=b+1,w=(l.vertex+1)*f*2,g=w+1;if(m[b]=m[b+f]=x[0],m[P]=m[P+f]=x[1],m[w]=m[w+f]=x[0],m[g]=m[g+f]=x[1],c){var j=b+2,S=w+2;m[j]=m[j+f]=x[2],m[S]=m[S+f]=x[2]}var k=2*l.vertex,_=2*(l.vertex+1);h[k+0]=v,h[k+1]=-v,h[_+0]=v,h[_+1]=-v;var I=2*l.vertex*2,C=I+1,M=2*(l.vertex+1)*2,T=M+1;p[I]=1,p[I+2]=-1,p[M]=1,p[M+2]=-1,p[C]=p[C+2]=0,p[T]=p[T+2]=0;var A=4*l.vertex*2,E=A+1,L=A+2,O=A+3,V=4*(l.vertex+1)*2,F=V+1,D=V+2,W=V+3;y[A]=y[A+4]=u[0],y[E]=y[E+4]=u[1],y[L]=y[L+4]=u[2],y[O]=y[O+4]=u[3],y[V]=y[V+4]=u[0],y[F]=y[F+4]=u[1],y[D]=y[D+4]=u[2],y[W]=y[W+4]=u[3],t.vec2.copy(a,x),s.addPoint(x),l.vertex+=2},lineTo:function(e,r,i,n){var o=i||0,s=this.state,a=s.activePath,c=s.prevPosition,l=s.is3d,f=s.cursor,u=f.dimensions,v=s.style.color,d=.5*s.style.lineWidth,m=this.resources,h=m.position.view,p=m.offset.view,y=m.color.view,x=m.ud.view,b=m.elements.view,P=this.transformInput(e,r,o),w=t.vec2.distance(c,P),g=a.totalLength+=w,j=f.vertex*u*2,S=j+1;if(h[j]=h[j+u]=P[0],h[S]=h[S+u]=P[1],l){var k=j+2;h[k]=h[k+u]=P[2]}var _=2*f.vertex;p[_]=d,p[_+1]=-d;var I=2*(f.vertex-1)*2,C=I+1;x[I]=1,x[I+2]=-1,x[C]=x[C+2]=g;var M=4*f.vertex*2,T=M+1,A=M+2,E=M+3;y[M]=y[M+4]=v[0],y[T]=y[T+4]=v[1],y[A]=y[A+4]=v[2],y[E]=y[E+4]=v[3];var L=6*f.quad,O=f.element,V=O+1,F=O+2,D=O+3;b[L+0]=O,b[L+1]=V,b[L+2]=F,b[L+3]=F,b[L+4]=V,b[L+5]=D,t.vec2.copy(c,P),a.addPoint(P),f.quad+=1,f.element+=2,f.vertex+=1},arc:function(e,t,r,i,n,o){for(var s=Math.abs(n-i),a=!0===o?-1:1,c=Math.ceil(s/(Math.PI/10)),l=0;l<c;l++){var f=i+l/(c-1)*s*a,u=e+Math.cos(f)*r,v=t+Math.sin(f)*r;0===l?this.moveTo(u,v):this.lineTo(u,v)}},closePath:function(){var e=this.state,t=e.activePath,r=e.cursor,i=r.dimensions,n=e.is3d,o=this.resources.position.view,s=(r.vertex-t.count)*i*2,a=o[s],c=o[s+1],l=n?o[s+2]:0;t.isClosed=!0,this.lineTo(a,c,l)},stroke:function(){var e=this.state,t=e.activePath,r=e.is3d,i=e.cursor,n=i.dimensions,o=this.resources,s=o.position.view,a=o.offset.view,c=o.ud.view,l=o.color.view,f=i.vertex-t.count,u=i.vertex-1,v=i.vertex,d=u*n*2,m=d+1,h=v*n*2,p=h+1;if(s[h]=s[h+n]=s[d],s[p]=s[p+n]=s[m],r){var y=h+2,x=d+2;s[y]=s[y+n]=s[x]}var b=2*u,P=2*v;a[P]=a[b],a[P+1]=a[b+1];var w=2*u*2+1,g=2*v*2,j=g+1;c[g]=1,c[g+2]=-1,c[j]=c[j+2]=c[w];var S=4*u*2,k=S+1,_=S+2,I=S+3,C=4*v*2,M=C+1,T=C+2,A=C+3;l[C]=l[C+4]=l[S],l[M]=l[M+4]=l[k],l[T]=l[T+4]=l[_],l[A]=l[A+4]=l[I],i.element+=6,i.vertex+=1,t.isClosed&&(this.copyPosition(f-1,u-1),this.copyPosition(v,f+1))},strokeRect:function(e,t,r,i){this.beginPath(),this.moveTo(e,t),this.lineTo(e+r,t),this.lineTo(e+r,t+i),this.lineTo(e,t+i),this.closePath(),this.stroke()},fill:function(){for(var e=this.state,t=e.cursor,i=e.activePath,n=e.style.fillColor,o=this.resources,s=o.fillPosition.view,a=o.fillColor.view,c=o.fillElements.view,l=i.points,f=i.count+(i.isClosed?-1:0),u=new Float32Array(2*f),v=t.fillVertex,d=2*v,m=4*v,h=3*t.fillTri,p=0;p<f;p++){var y=l[p],x=2*p,b=x+1;s[d+x]=u[x]=y[0],s[d+b]=u[b]=y[1];var P=4*p,w=P+1,g=P+2,j=P+3;a[m+P]=n[0],a[m+w]=n[1],a[m+g]=n[2],a[m+j]=n[3]}for(var S=r(u),k=S.length/3,_=0;_<k;_++){var I=3*_;c[h+I+0]=v+S[I+0],c[h+I+1]=v+S[I+1],c[h+I+2]=v+S[I+2]}t.fillVertex+=f,t.fillTri+=k},methods2d:{setTransform:function(e,r,i,n,o,s){var a=this.state.transform;t.mat2d.set(a.matrix,e,r,i,n,o,s),a.isIdentity=!1},translate:function(e,r){var i=this.state.transform,n=t.vec2.set(v,e,r);t.mat2d.translate(i.matrix,i.matrix,n),i.isIdentity=!1},scale:function(e,r){var i=this.state.transform,n=t.vec2.set(v,e,r);t.mat2d.scale(i.matrix,i.matrix,n),i.isIdentity=!1},rotate:function(e){var r=this.state.transform;t.mat2d.rotate(r.matrix,r.matrix,e),r.isIdentity=!1}},methods3d:{setTransform:function(e,r,i,n,o,s,a,c,l,f,u,v,d,m,h,p){var y=this.state.transform;t.mat4.set(y.matrix,e,r,i,n,o,s,a,c,l,f,u,v,d,m,h,p),y.isIdentity=!1},translate:function(e,r,i){var n=this.state.transform,o=t.vec3.set(v,e,r,i);t.mat4.translate(n.matrix,n.matrix,o),n.isIdentity=!1},scale:function(e,r,i){var n=this.state.transform,o=t.vec3.set(v,e,r,i);t.mat4.scale(n.matrix,n.matrix,o),n.isIdentity=!1},rotate:function(e,r){var i=this.state.transform;switch(r){case"x":t.mat4.rotateX(i.matrix,i.matrix,e);break;case"y":t.mat4.rotateY(i.matrix,i.matrix,e);break;case"z":t.mat4.rotateZ(i.matrix,i.matrix,e);break;default:t.mat4.rotate(i.matrix,i.matrix,e,r)}i.isIdentity=!1}},accessors:{lineWidth:function(e){return{get:function(){return e.style.lineWidth},set:function(t){return e.style.lineWidth=t,t}}},globalAlpha:function(e){return{get:function(){return e.style.color[3]},set:function(t){return e.style.color[3]=t,e.style.fillColor[3]=t,t}}},strokeStyle:function(e){return{get:function(){return e.style.strokeStyle},set:function(t){return o(e.style.color,t),e.style.strokeStyle=t,t}}},fillStyle:function(e){return{get:function(){return e.style.fillStyle},set:function(t){return o(e.style.fillColor,t),e.style.fillStyle=t,t}}}},transformInput:function(e,r,i){var n,o=i||0,s=this.state,a=s.is3d,c=s.activePath,l=s.transform;return a?(n=t.vec3.set(v,e,r,o),l.isIdentity||c.isClosed||t.vec3.transformMat4(n,n,l.matrix)):(n=t.vec2.set(v,e,r),l.isIdentity||c.isClosed||t.vec2.transformMat2d(n,n,l.matrix)),n},copyPosition:function(e,t){var r=this.state,i=r.is3d,n=r.cursor.dimensions,o=this.resources.position.view,s=e*n*2,a=s+1,c=t*n*2,l=c+1;if(o[s]=o[s+n]=o[c],o[a]=o[a+n]=o[l],i){var f=s+2,u=c+2;o[f]=o[f+n]=o[u]}}}),e.LineBuilder=d,e.line=s,Object.defineProperty(e,"__esModule",{value:!0})});
