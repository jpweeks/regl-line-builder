!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("gl-matrix"),require("earcut")):"function"==typeof define&&define.amd?define(["exports","gl-matrix","earcut"],t):t(e.REGLLineBuilder={},{vec2:e.vec2,vec3:e.vec3,mat2d:e.mat2d,mat4:e.mat4},e.earcut)}(this,function(e,t,i){"use strict";function r(e,t,i){t.create=function(e){return function(){var t=Object.create(e.prototype);return e.apply(t,arguments),t}}(t),e&&(t.prototype=Object.create(e.prototype)),t.prototype.constructor=t,Object.assign(t.prototype,i)}function n(e){this.dimensions=e.dimensions,this.offset=0,this.count=0,this.totalLength=0,this.isClosed=!1,this.points=[]}function s(e,t){var i=parseInt(t.replace(/^#/,""),16),r=Math.floor(i);e[0]=(r>>16&255)/255,e[1]=(r>>8&255)/255,e[2]=(255&r)/255}i=i&&i.hasOwnProperty("default")?i.default:i,r(null,n,{reset:function(){this.offset=0,this.count=0,this.totalLength=0,this.isClosed=!1},addPoint:function(e){var i=this.points,r=this.dimensions,n=i[this.count++];n||(n=2===r?t.vec2.create():t.vec3.create(),i.push(n)),2===r?t.vec2.copy(n,e):t.vec3.copy(n,e)}});var o={frag:"precision highp float;\n#define GLSLIFY 1\nuniform vec4 tint;\nvarying vec4 vColor;\nvarying vec2 vUD;\n\nvoid main() {\n  gl_FragColor = vColor * tint;\n}\n",vert:"precision highp float;\n#define GLSLIFY 1\n\n// Based on WebGL lines demo\n// (c) 2015 Matt DesLauriers. MIT License\n// https://github.com/mattdesl/webgl-lines/\n\n// TODO: Maybe make separate package to make reuse with custom shaders easier?\n// TODO: Maybe use struct to pass some of this data?\nvec2 computeMiterOffset (\n  mat4 projection_0,\n  int adjustProjectedThickness_0,\n  float aspect_0,\n  float thickness_0,\n  float miterLimit_0,\n  float prevId_0,\n  float currId_0,\n  float nextId_0,\n  vec4 prevProjected_0,\n  vec4 currProjected_0,\n  vec4 nextProjected_0\n) {\n  vec2 aspectVec = vec2(aspect_0, 1.0);\n\n  // get 2D screen space with W divide and aspect correction\n  vec2 prevScreen = prevProjected_0.xy / prevProjected_0.w * aspectVec;\n  vec2 currScreen = currProjected_0.xy / currProjected_0.w * aspectVec;\n  vec2 nextScreen = nextProjected_0.xy / nextProjected_0.w * aspectVec;\n\n  float thicknessScale = 1.0;\n  if (adjustProjectedThickness_0 == 1) {\n    vec4 singlePixelProjected = projection_0 * vec4(2.0, 0.0, 0.0, 1.0);\n    vec2 singlePixel = singlePixelProjected.xy / singlePixelProjected.w * aspectVec;\n    thicknessScale = singlePixel.x;\n  }\n\n  vec2 dir = vec2(0.0);\n  float len = thickness_0 * thicknessScale;\n\n  // starting point uses (next - current)\n  if (currId_0 > prevId_0) {\n    dir = normalize(nextScreen - currScreen);\n  }\n  // ending point uses (current - previous)\n  else if (currId_0 < nextId_0) {\n    dir = normalize(currScreen - prevScreen);\n  }\n  // somewhere in middle, needs a join\n  else {\n    // get directions from (C - B) and (B - A)\n    vec2 dirA = normalize((currScreen - prevScreen));\n    if (int(miterLimit_0) == -1) {\n      dir = dirA;\n    } else {\n      vec2 dirB = normalize((nextScreen - currScreen));\n      // now compute the miter join normal and length\n      vec2 tangent = normalize(dirA + dirB);\n      vec2 perp = vec2(-dirA.y, dirA.x);\n      vec2 miter = vec2(-tangent.y, tangent.x);\n      dir = tangent;\n      len /= dot(miter, perp);\n    }\n  }\n\n  return vec2(-dir.y, dir.x) *\n    clamp(len, 0.0, miterLimit_0 * thicknessScale) / aspectVec;\n}\n\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\nuniform float aspect;\nuniform int adjustProjectedThickness;\n\nuniform float thickness;\nuniform float miterLimit;\n\n#ifdef DIMENSIONS_3\nattribute vec3 prevPosition;\nattribute vec3 currPosition;\nattribute vec3 nextPosition;\n#else\nattribute vec2 prevPosition;\nattribute vec2 currPosition;\nattribute vec2 nextPosition;\n#endif\n\nattribute float prevId;\nattribute float currId;\nattribute float nextId;\n\nattribute float offset;\nattribute vec4 color;\nattribute vec2 ud;\n\nvarying vec4 vColor;\nvarying vec2 vUD;\n\nvoid main() {\n  mat4 projViewModel = projection * view * model;\n\n#ifdef DIMENSIONS_3\n  vec4 prevProjected = projViewModel * vec4(prevPosition, 1.0);\n  vec4 currProjected = projViewModel * vec4(currPosition, 1.0);\n  vec4 nextProjected = projViewModel * vec4(nextPosition, 1.0);\n#else\n  vec4 prevProjected = projViewModel * vec4(prevPosition, 0.0, 1.0);\n  vec4 currProjected = projViewModel * vec4(currPosition, 0.0, 1.0);\n  vec4 nextProjected = projViewModel * vec4(nextPosition, 0.0, 1.0);\n#endif\n\n  vec2 miterOffset = computeMiterOffset(\n    projection, adjustProjectedThickness,\n    aspect, thickness, miterLimit,\n    prevId, currId, nextId,\n    prevProjected, currProjected, nextProjected);\n\n  vColor = color;\n  vUD = ud;\n\n  gl_Position = currProjected + vec4(miterOffset * offset, 0.0, 1.0);\n}\n"},a="precision highp float;\n#define GLSLIFY 1\nuniform vec4 tint;\nvarying vec4 vColor;\n\nvoid main() {\n  gl_FragColor = vColor * tint;\n}\n",c="precision highp float;\n#define GLSLIFY 1\n\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\n\n// #ifdef DIMENSIONS_3\n// attribute vec3 position;\n// #else\nattribute vec2 position;\n// #endif\n\nattribute vec4 color;\nattribute float id;\n\nvarying vec4 vColor;\n\nvoid main() {\n  mat4 projViewModel = projection * view * model;\n  vec4 posProjected = projViewModel * vec4(position, 0.0, 1.0);\n\n  vColor = color;\n\n  gl_Position = posProjected * vec4(0.5, 0.5, 0.0, 1.0);\n}\n",l=Float32Array.BYTES_PER_ELEMENT,f=["beginPath","moveTo","lineTo","arc","closePath","stroke","strokeRect","fill","setTransform","translate","scale","rotate","save","restore"],u=["globalAlpha","lineWidth","strokeStyle","fillStyle"],d=t.vec3.create();function v(e,t){var i,r,n,s=t||{};s.dimensions=(i=s.dimensions||2,r=2,n=3,Math.max(Math.min(i,n),r)),s.bufferSize=s.bufferSize||1024,this.ctorOptions=s,this.context=this.createContext(e),this.state=this.createState(s),this.resources=this.createResources(),this.attributes=this.createAttributes(),this.draw=this.createDrawCommand(s)}r(null,v,{createContext:function(e){return{regl:e}},createState:function(e){var i=3===e.dimensions;return{is3d:i,cursor:{vertex:0,element:0,quad:0,fillVertex:0,fillElement:0,fillTri:0,dimensions:e.dimensions,max:e.bufferSize},sync:{vertex:0},style:{color:new Float32Array([0,0,0,1]),lineWidth:1,strokeStyle:"#000000",fillColor:new Float32Array([0,0,0,1]),fillStyle:"#000000"},transform:{isIdentity:!0,matrix:i?t.mat4.create():t.mat2d.create()},activePath:null,prevPosition:t.vec3.create(),saveStack:[],pathCount:0,scratchPath:n.create({dimensions:e.dimensions})}},createResources:function(){var e=this.context.regl,t=this.state.cursor,i=this.createResourceViews(t.max,t.dimensions),r=i.lines.views,n=i.fills.views,s=e.buffer({usage:"dynamic",type:"float",data:i.lines.dataView}),o=e.buffer({usage:"dynamic",type:"float",data:i.fills.dataView}),a=e.elements({usage:"dynamic",primitive:"triangles",data:i.elements}),c=e.elements({usage:"dynamic",primitive:"triangles",data:i.fillElements});return{lines:{view:i.lines.dataView,locs:i.lines.locs,buffer:s},fills:{view:i.fills.dataView,locs:i.fills.locs,buffer:o},elements:{view:i.elements,buffer:a},fillElements:{view:i.fillElements,buffer:c},position:{view:r.position},offset:{view:r.offset},color:{view:r.color},ud:{view:r.ud},id:{view:r.id},fillPosition:{view:n.fillPosition},fillColor:{view:n.fillColor},fillId:{view:n.fillId}}},createResourceViews:function(e,t){var i=this.getElementsCtor(e);return{lines:this.createLinesResourceViews(e,t),fills:this.createFillsResourceViews(e,t),elements:new i(4*e),fillElements:new i(3*e)}},createLinesResourceViews:function(e,t){return this.createResourceViewsForSizes([["position",2*e*t],["offset",2*e*1],["color",2*e*4],["ud",2*e*2],["id",2*e*1]])},createFillsResourceViews:function(e,t){return this.createResourceViewsForSizes([["fillPosition",e*t],["fillColor",4*e],["fillId",1*e]])},createResourceViewsForSizes:function(e){var t=e.reduce((e,[t,i])=>(e.data[t]={offset:e.offset,size:i},e.offset+=i,e),{offset:0,data:{}}),i=new ArrayBuffer(t.offset*l),r=new Float32Array(i),n=e.reduce((e,[t,r])=>(e.data[t]=new Float32Array(i,e.offset*l,r),e.offset+=r,e),{offset:0,data:{}});return{data:i,dataView:r,locs:t.data,views:n.data}},getElementsCtor(e){var t=4*e*2>65536,i=this.context.regl.hasExtension("OES_element_index_uint");if(t&&!i)throw new Error("bufferSize is too big for Uint16Array, please enable OES_element_index_uint extension.");return t&&i?Uint32Array:Uint16Array},createAttributes:function(){var e=this.resources,t=this.state.cursor.dimensions,i=e.lines,r=e.fills;return{line:{prevPosition:{buffer:i.buffer,offset:0,stride:l*t},currPosition:{buffer:i.buffer,offset:l*t*2,stride:l*t},nextPosition:{buffer:i.buffer,offset:l*t*4,stride:l*t},prevId:{buffer:i.buffer,offset:l*(i.locs.id.offset+0),stride:l},currId:{buffer:i.buffer,offset:l*(i.locs.id.offset+2),stride:l},nextId:{buffer:i.buffer,offset:l*(i.locs.id.offset+4),stride:l},offset:{buffer:i.buffer,offset:l*i.locs.offset.offset,stride:l},ud:{buffer:i.buffer,offset:l*i.locs.ud.offset,stride:2*l},color:{buffer:i.buffer,offset:l*i.locs.color.offset,stride:4*l}},fill:{position:{buffer:r.buffer,offset:l*r.locs.fillPosition.offset,stride:l*t},color:{buffer:r.buffer,offset:l*r.locs.fillColor.offset,stride:4*l},id:{buffer:r.buffer,offset:l*r.locs.fillId.offset,stride:1*l}}}},combineDrawArgs:function(e,t){var i=Object.assign({},e);return Object.keys(t).forEach(function(r){i[r]="uniforms"===r||"attributes"===r?Object.assign({},e[r],t[r]):t[r]}),i},createDrawCommand:function(e){var t=this.attributes,i=this.context.regl,r=this.resources,n=this.state,s={line:{model:i.prop("model"),tint:i.prop("tint"),aspect:function(e,t){return e.viewportWidth/e.viewportHeight},thickness:i.prop("thickness"),miterLimit:i.prop("miterLimit"),adjustProjectedThickness:function(e,t){return!0===t.adjustProjectedThickness?1:0}},fill:{model:i.prop("model"),tint:i.prop("tint")}},l={enable:!0},f={enable:!0,face:"back"},u={enable:!0,equation:"add",func:{src:"src alpha",dst:"one minus src alpha"}},d={vert:o.vert,frag:o.frag,uniforms:s.line,attributes:t.line,elements:r.elements.buffer,count:function(){return 6*n.cursor.quad},depth:l,cull:f,blend:u},v=e.drawLineArgs?this.combineDrawArgs(d,e.drawLineArgs):d,m={vert:c,frag:a,uniforms:s.fill,attributes:t.fill,elements:r.fillElements.buffer,count:function(){return 3*n.cursor.fillTri},depth:l,cull:f,blend:u},h=e.drawFillArgs?this.combineDrawArgs(m,e.drawFillArgs):m;if(n.is3d){v.vert="#define DIMENSIONS_3\n"+v.vert,v.frag="#define DIMENSIONS_3\n"+v.frag}var p=i(v),x=i(h);return function(e){n.sync.vertex<n.cursor.vertex&&(this.syncResourceBuffers(),n.sync.vertex=n.cursor.vertex),x(e),p(e)}.bind(this)},syncResourceBuffers:function(){var e=this.resources,t=e.lines,i=e.elements,r=e.fills,n=e.fillElements;t.buffer.subdata(t.view),i.buffer.subdata(i.view),r.buffer.subdata(r.view),n.buffer.subdata(n.view)},getContext:function(e){var t=this,i=this.state,r={},n=this["methods"+(e||"2d")],s=this,o=this.accessors;return f.forEach(function(e){var i=n[e]||s[e];i&&(r[e]=i.bind(t))}),u.forEach(function(e){var t=o[e];Object.defineProperty(r,e,t(i))}),r},resize:function(e){var t=this.ctorOptions,i=this.state.cursor,r=this.resources,n=this.createResourceViews(e,i.dimensions);i.max=e,Object.keys(n).forEach(function(e){var t=r[e],i=n[e];t.locs?(t.view=i.dataView,t.locs=i.locs,Object.keys(i.views).forEach(function(e){r[e].view=i.views[e]})):t.view=i,t.buffer&&t.buffer({data:t.view})}),this.attributes=this.createAttributes(),this.draw=this.createDrawCommand(t)},reset:function(){var e=this.state,i=e.is3d,r=e.cursor,n=e.sync,s=e.style,o=e.transform;r.vertex=0,r.element=0,r.quad=0,r.fillVertex=0,r.fillElement=0,r.fillTri=0,n.vertex=0,s.lineWidth=1,s.color[0]=0,s.color[1]=0,s.color[2]=0,s.color[3]=1,o.isIdentity=!0,i?t.mat4.identity(o.matrix):t.mat2d.identity(o.matrix),e.activePath=null,e.pathCount=0,e.saveStack.length=0},destroy:function(){var e=this.resources;Object.keys(e).forEach(function(t){var i=e[t];i.buffer&&i.buffer.destroy()})},save:function(){var e=this.state,i=e.is3d,r=e.style,n=e.transform;e.saveStack.push({style:{lineWidth:r.lineWidth,color:r.color.slice()},transform:{isIdentity:n.isIdentity,matrix:i?t.mat4.clone(n.matrix):t.mat2d.clone(n.matrix)}})},restore:function(){var e=this.state,t=e.style,i=e.transform,r=e.saveStack.pop(),n=r.style,s=r.transform;t.lineWidth=n.lineWidth,t.color=n.color,i.isIdentity=s.isIdentity,i.matrix=s.matrix},beginPath:function(){var e=this.state,t=e.activePath,i=t?t.offset+t.count:0,r=e.scratchPath;r.reset(),r.offset=i,e.activePath=r},moveTo:function(e,i,r){var n=r||0,s=this.state,o=s.activePath,a=s.prevPosition,c=s.is3d,l=s.cursor,f=l.dimensions,u=++s.pathCount,d=s.style.color,v=.5*s.style.lineWidth,m=this.resources,h=m.position.view,p=m.offset.view,x=m.ud.view,y=m.id.view,b=m.color.view,w=this.transformInput(e,i,n),P=l.vertex*f*2,g=P+1,j=(l.vertex+1)*f*2,I=j+1;if(h[P]=h[P+f]=w[0],h[g]=h[g+f]=w[1],h[j]=h[j+f]=w[0],h[I]=h[I+f]=w[1],c){var S=P+2,_=j+2;h[S]=h[S+f]=w[2],h[_]=h[_+f]=w[2]}var k=2*l.vertex,C=2*(l.vertex+1);p[k+0]=v,p[k+1]=-v,p[C+0]=v,p[C+1]=-v;var V=2*l.vertex*2,E=V+1,M=2*(l.vertex+1)*2,T=M+1;x[V]=1,x[V+2]=-1,x[M]=1,x[M+2]=-1,x[E]=x[E+2]=0,x[T]=x[T+2]=0;var L=2*l.vertex,O=2*(l.vertex+1);y[L]=y[L+1]=u-1,y[O]=y[O+1]=u;var A=4*l.vertex*2,F=A+1,D=A+2,R=A+3,z=4*(l.vertex+1)*2,W=z+1,B=z+2,N=z+3;b[A]=b[A+4]=d[0],b[F]=b[F+4]=d[1],b[D]=b[D+4]=d[2],b[R]=b[R+4]=d[3],b[z]=b[z+4]=d[0],b[W]=b[W+4]=d[1],b[B]=b[B+4]=d[2],b[N]=b[N+4]=d[3],t.vec2.copy(a,w),o.addPoint(w),l.vertex+=2},lineTo:function(e,i,r,n){var s=r||0,o=this.state,a=o.activePath,c=o.prevPosition,l=o.is3d,f=o.cursor,u=f.dimensions,d=o.pathCount,v=o.style.color,m=.5*o.style.lineWidth,h=this.resources,p=h.position.view,x=h.offset.view,y=h.color.view,b=h.ud.view,w=h.id.view,P=h.elements.view,g=this.transformInput(e,i,s),j=t.vec2.distance(c,g),I=a.totalLength+=j,S=f.vertex*u*2,_=S+1;if(p[S]=p[S+u]=g[0],p[_]=p[_+u]=g[1],l){var k=S+2;p[k]=p[k+u]=g[2]}var C=2*f.vertex;x[C]=m,x[C+1]=-m;var V=2*(f.vertex-1)*2,E=V+1;b[V]=1,b[V+2]=-1,b[E]=b[E+2]=I;var M=2*f.vertex;w[M]=w[M+1]=d;var T=4*f.vertex*2,L=T+1,O=T+2,A=T+3;y[T]=y[T+4]=v[0],y[L]=y[L+4]=v[1],y[O]=y[O+4]=v[2],y[A]=y[A+4]=v[3];var F=6*f.quad,D=f.element,R=D+1,z=D+2,W=D+3;P[F+0]=D,P[F+1]=R,P[F+2]=z,P[F+3]=z,P[F+4]=R,P[F+5]=W,t.vec2.copy(c,g),a.addPoint(g),f.quad+=1,f.element+=2,f.vertex+=1},arc:function(e,t,i,r,n,s){for(var o=Math.abs(n-r),a=!0===s?-1:1,c=Math.ceil(o/(Math.PI/10)),l=0;l<c;l++){var f=r+l/(c-1)*o*a,u=e+Math.cos(f)*i,d=t+Math.sin(f)*i;0===l?this.moveTo(u,d):this.lineTo(u,d)}},closePath:function(){var e=this.state,t=e.activePath,i=e.cursor,r=i.dimensions,n=e.is3d,s=this.resources.position.view,o=(i.vertex-t.count)*r*2,a=s[o],c=s[o+1],l=n?s[o+2]:0;t.isClosed=!0,this.lineTo(a,c,l)},stroke:function(){var e=this.state,t=e.activePath,i=e.is3d,r=e.cursor,n=r.dimensions,s=e.pathCount,o=this.resources,a=o.position.view,c=o.offset.view,l=o.ud.view,f=o.id.view,u=o.color.view,d=r.vertex-t.count,v=r.vertex-1,m=r.vertex,h=v*n*2,p=h+1,x=m*n*2,y=x+1;if(a[x]=a[x+n]=a[h],a[y]=a[y+n]=a[p],i){var b=x+2,w=h+2;a[b]=a[b+n]=a[w]}var P=2*v,g=2*m;c[g]=c[P],c[g+1]=c[P+1];var j=2*v*2+1,I=2*m*2,S=I+1;l[I]=1,l[I+2]=-1,l[S]=l[S+2]=l[j];var _=2*r.vertex;f[_]=f[_+1]=s+1;var k=4*v*2,C=k+1,V=k+2,E=k+3,M=4*m*2,T=M+1,L=M+2,O=M+3;u[M]=u[M+4]=u[k],u[T]=u[T+4]=u[C],u[L]=u[L+4]=u[V],u[O]=u[O+4]=u[E],r.element+=6,r.vertex+=1,t.isClosed&&(this.copyPosition(d-1,v-1),this.copyPosition(m,d+1))},strokeRect:function(e,t,i,r){this.beginPath(),this.moveTo(e,t),this.lineTo(e+i,t),this.lineTo(e+i,t+r),this.lineTo(e,t+r),this.closePath(),this.stroke()},fill:function(){for(var e=this.state,t=e.cursor,r=e.activePath,n=e.pathCount,s=e.style.fillColor,o=this.resources,a=o.fillPosition.view,c=o.fillColor.view,l=o.fillId.view,f=o.fillElements.view,u=r.points,d=r.count+(r.isClosed?-1:0),v=new Float32Array(2*d),m=t.fillVertex,h=2*m,p=4*m,x=3*t.fillTri,y=0;y<d;y++){var b=u[y],w=2*y,P=w+1;a[h+w]=v[w]=b[0],a[h+P]=v[P]=b[1],l[m+y]=n;var g=4*y,j=g+1,I=g+2,S=g+3;c[p+g]=s[0],c[p+j]=s[1],c[p+I]=s[2],c[p+S]=s[3]}for(var _=i(v),k=_.length/3,C=0;C<k;C++){var V=3*C;f[x+V+0]=m+_[V+0],f[x+V+1]=m+_[V+1],f[x+V+2]=m+_[V+2]}t.fillVertex+=d,t.fillTri+=k},methods2d:{setTransform:function(e,i,r,n,s,o){var a=this.state.transform;t.mat2d.set(a.matrix,e,i,r,n,s,o),a.isIdentity=!1},translate:function(e,i){var r=this.state.transform,n=t.vec2.set(d,e,i);t.mat2d.translate(r.matrix,r.matrix,n),r.isIdentity=!1},scale:function(e,i){var r=this.state.transform,n=t.vec2.set(d,e,i);t.mat2d.scale(r.matrix,r.matrix,n),r.isIdentity=!1},rotate:function(e){var i=this.state.transform;t.mat2d.rotate(i.matrix,i.matrix,e),i.isIdentity=!1}},methods3d:{setTransform:function(e,i,r,n,s,o,a,c,l,f,u,d,v,m,h,p){var x=this.state.transform;t.mat4.set(x.matrix,e,i,r,n,s,o,a,c,l,f,u,d,v,m,h,p),x.isIdentity=!1},translate:function(e,i,r){var n=this.state.transform,s=t.vec3.set(d,e,i,r);t.mat4.translate(n.matrix,n.matrix,s),n.isIdentity=!1},scale:function(e,i,r){var n=this.state.transform,s=t.vec3.set(d,e,i,r);t.mat4.scale(n.matrix,n.matrix,s),n.isIdentity=!1},rotate:function(e,i){var r=this.state.transform;switch(i){case"x":t.mat4.rotateX(r.matrix,r.matrix,e);break;case"y":t.mat4.rotateY(r.matrix,r.matrix,e);break;case"z":t.mat4.rotateZ(r.matrix,r.matrix,e);break;default:t.mat4.rotate(r.matrix,r.matrix,e,i)}r.isIdentity=!1}},accessors:{lineWidth:function(e){return{get:function(){return e.style.lineWidth},set:function(t){return e.style.lineWidth=t,t}}},globalAlpha:function(e){return{get:function(){return e.style.color[3]},set:function(t){return e.style.color[3]=t,e.style.fillColor[3]=t,t}}},strokeStyle:function(e){return{get:function(){return e.style.strokeStyle},set:function(t){return s(e.style.color,t),e.style.strokeStyle=t,t}}},fillStyle:function(e){return{get:function(){return e.style.fillStyle},set:function(t){return s(e.style.fillColor,t),e.style.fillStyle=t,t}}}},transformInput:function(e,i,r){var n,s=r||0,o=this.state,a=o.is3d,c=o.activePath,l=o.transform;return a?(n=t.vec3.set(d,e,i,s),l.isIdentity||c.isClosed||t.vec3.transformMat4(n,n,l.matrix)):(n=t.vec2.set(d,e,i),l.isIdentity||c.isClosed||t.vec2.transformMat2d(n,n,l.matrix)),n},copyPosition:function(e,t){var i=this.state,r=i.is3d,n=i.cursor.dimensions,s=this.resources,o=s.position.view,a=s.id.view,c=e*n*2,l=c+1,f=t*n*2,u=f+1;if(o[c]=o[c+n]=o[f],o[l]=o[l+n]=o[u],r){var d=c+2,v=f+2;o[d]=o[d+n]=o[v]}var m=2*e,h=2*t;a[m]=a[m+1]=a[h]}}),e.LineBuilder=v,e.line=o,Object.defineProperty(e,"__esModule",{value:!0})});
