!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("gl-matrix"),require("earcut")):"function"==typeof define&&define.amd?define(["exports","gl-matrix","earcut"],t):t(e.REGLLineBuilder={},{vec2:e.vec2,vec3:e.vec3,mat2d:e.mat2d,mat4:e.mat4},e.earcut)}(this,function(e,t,r){"use strict";function i(e,t,r){t.create=function(e){return function(){var t=Object.create(e.prototype);return e.apply(t,arguments),t}}(t),e&&(t.prototype=Object.create(e.prototype)),t.prototype.constructor=t,Object.assign(t.prototype,r)}function n(e){this.dimensions=e.dimensions,this.offset=0,this.count=0,this.totalLength=0,this.isClosed=!1,this.points=[]}function o(e,t){var r=parseInt(t.replace(/^#/,""),16),i=Math.floor(r);e[0]=(i>>16&255)/255,e[1]=(i>>8&255)/255,e[2]=(255&i)/255}r=r&&r.hasOwnProperty("default")?r.default:r,i(null,n,{reset:function(){this.offset=0,this.count=0,this.totalLength=0,this.isClosed=!1},addPoint:function(e){var r=this.points,i=this.dimensions,n=r[this.count++];n||(n=2===i?t.vec2.create():t.vec3.create(),r.push(n)),2===i?t.vec2.copy(n,e):t.vec3.copy(n,e)}});var s={frag:"precision highp float;\n#define GLSLIFY 1\nuniform vec4 tint;\nvarying vec4 vColor;\nvarying vec2 vUD;\n\nvoid main() {\n  gl_FragColor = vColor * tint;\n}\n",vert:"precision highp float;\n#define GLSLIFY 1\n\n// Based on WebGL lines demo\n// (c) 2015 Matt DesLauriers. MIT License\n// https://github.com/mattdesl/webgl-lines/\n\n// TODO: Maybe make separate package to make reuse with custom shaders easier?\n// TODO: Maybe use struct to pass some of this data?\nvec2 computeMiterOffset (\n  mat4 projection_0,\n  int adjustProjectedThickness_0,\n  float aspect_0,\n  float thickness_0,\n  float miterLimit_0,\n  float prevId_0,\n  float currId_0,\n  float nextId_0,\n  vec4 prevProjected_0,\n  vec4 currProjected_0,\n  vec4 nextProjected_0\n) {\n  vec2 aspectVec = vec2(aspect_0, 1.0);\n\n  // get 2D screen space with W divide and aspect correction\n  vec2 prevScreen = prevProjected_0.xy / prevProjected_0.w * aspectVec;\n  vec2 currScreen = currProjected_0.xy / currProjected_0.w * aspectVec;\n  vec2 nextScreen = nextProjected_0.xy / nextProjected_0.w * aspectVec;\n\n  float thicknessScale = 1.0;\n  if (adjustProjectedThickness_0 == 1) {\n    vec4 singlePixelProjected = projection_0 * vec4(2.0, 0.0, 0.0, 1.0);\n    vec2 singlePixel = singlePixelProjected.xy / singlePixelProjected.w * aspectVec;\n    thicknessScale = singlePixel.x;\n  }\n\n  vec2 dir = vec2(0.0);\n  float len = thickness_0 * thicknessScale;\n\n  // starting point uses (next - current)\n  if (currId_0 > prevId_0) {\n    dir = normalize(nextScreen - currScreen);\n  }\n  // ending point uses (current - previous)\n  else if (currId_0 < nextId_0) {\n    dir = normalize(currScreen - prevScreen);\n  }\n  // somewhere in middle, needs a join\n  else {\n    // get directions from (C - B) and (B - A)\n    vec2 dirA = normalize((currScreen - prevScreen));\n    if (int(miterLimit_0) == -1) {\n      dir = dirA;\n    } else {\n      vec2 dirB = normalize((nextScreen - currScreen));\n      // now compute the miter join normal and length\n      vec2 tangent = normalize(dirA + dirB);\n      vec2 perp = vec2(-dirA.y, dirA.x);\n      vec2 miter = vec2(-tangent.y, tangent.x);\n      dir = tangent;\n      len /= dot(miter, perp);\n    }\n  }\n\n  return vec2(-dir.y, dir.x) *\n    clamp(len, 0.0, miterLimit_0 * thicknessScale) / aspectVec;\n}\n\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\nuniform float aspect;\nuniform int adjustProjectedThickness;\n\nuniform float thickness;\nuniform float miterLimit;\n\n#ifdef DIMENSIONS_3\nattribute vec3 prevPosition;\nattribute vec3 currPosition;\nattribute vec3 nextPosition;\n#else\nattribute vec2 prevPosition;\nattribute vec2 currPosition;\nattribute vec2 nextPosition;\n#endif\n\nattribute float prevId;\nattribute float currId;\nattribute float nextId;\n\nattribute float offset;\nattribute vec4 color;\nattribute vec2 ud;\n\nvarying vec4 vColor;\nvarying vec2 vUD;\n\nvoid main() {\n  mat4 projViewModel = projection * view * model;\n\n#ifdef DIMENSIONS_3\n  vec4 prevProjected = projViewModel * vec4(prevPosition, 1.0);\n  vec4 currProjected = projViewModel * vec4(currPosition, 1.0);\n  vec4 nextProjected = projViewModel * vec4(nextPosition, 1.0);\n#else\n  vec4 prevProjected = projViewModel * vec4(prevPosition, 0.0, 1.0);\n  vec4 currProjected = projViewModel * vec4(currPosition, 0.0, 1.0);\n  vec4 nextProjected = projViewModel * vec4(nextPosition, 0.0, 1.0);\n#endif\n\n  vec2 miterOffset = computeMiterOffset(\n    projection, adjustProjectedThickness,\n    aspect, thickness, miterLimit,\n    prevId, currId, nextId,\n    prevProjected, currProjected, nextProjected);\n\n  vColor = color;\n  vUD = ud;\n\n  gl_Position = currProjected + vec4(miterOffset * offset, 0.0, 1.0);\n}\n"},a="precision highp float;\n#define GLSLIFY 1\nuniform vec4 tint;\nvarying vec4 vColor;\n\nvoid main() {\n  gl_FragColor = vColor * tint;\n}\n",c="precision highp float;\n#define GLSLIFY 1\n\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\n\n// #ifdef DIMENSIONS_3\n// attribute vec3 position;\n// #else\nattribute vec2 position;\n// #endif\n\nattribute vec4 color;\nattribute float id;\n\nvarying vec4 vColor;\n\nvoid main() {\n  mat4 projViewModel = projection * view * model;\n  vec4 posProjected = projViewModel * vec4(position, 0.0, 1.0);\n\n  vColor = color;\n\n  gl_Position = posProjected * vec4(0.5, 0.5, 0.0, 1.0);\n}\n",l=Float32Array.BYTES_PER_ELEMENT,f=["beginPath","moveTo","lineTo","arc","closePath","stroke","strokeRect","fill","setTransform","translate","scale","rotate","save","restore"],u=["globalAlpha","lineWidth","strokeStyle","fillStyle"],d=t.vec3.create();function v(e,t){var r,i,n,o=t||{};o.dimensions=(r=o.dimensions||2,i=2,n=3,Math.max(Math.min(r,n),i)),o.bufferSize=o.bufferSize||1024,this.context=this.createContext(e),this.state=this.createState(o),this.resources=this.createResources(),this.attributes=this.createAttributes(),this.draw=this.createDrawCommand(o)}i(null,v,{createContext:function(e){return{regl:e}},createState:function(e){var r=3===e.dimensions;return{is3d:r,cursor:{vertex:0,element:0,quad:0,fillVertex:0,fillElement:0,fillTri:0,dimensions:e.dimensions,max:e.bufferSize},sync:{vertex:0},style:{color:new Float32Array([0,0,0,1]),lineWidth:1,strokeStyle:"#000000",fillColor:new Float32Array([0,0,0,1]),fillStyle:"#000000"},transform:{isIdentity:!0,matrix:r?t.mat4.create():t.mat2d.create()},activePath:null,prevPosition:t.vec3.create(),saveStack:[],pathCount:0,scratchPath:n.create({dimensions:e.dimensions})}},createResources:function(){var e=this.context.regl,t=this.state.cursor,r=this.createResourceViews(t.max,t.dimensions),i=e.buffer({usage:"dynamic",type:"float",data:r.position}),n=e.buffer({usage:"dynamic",type:"float",data:r.offset}),o=e.buffer({usage:"dynamic",type:"float",data:r.color}),s=e.buffer({usage:"dynamic",type:"float",data:r.ud}),a=e.buffer({usage:"dynamic",type:"float",data:r.id}),c=e.elements({usage:"dynamic",primitive:"triangles",data:r.elements}),l=e.buffer({usage:"dynamic",type:"float",data:r.fillPosition}),f=e.buffer({usage:"dynamic",type:"float",data:r.fillColor}),u=e.buffer({usage:"dynamic",type:"float",data:r.fillId}),d=e.elements({usage:"dynamic",primitive:"triangles",data:r.fillElements});return{position:{view:r.position,buffer:i},offset:{view:r.offset,buffer:n},color:{view:r.color,buffer:o},ud:{view:r.ud,buffer:s},id:{view:r.id,buffer:a},elements:{view:r.elements,buffer:c},fillPosition:{view:r.fillPosition,buffer:l},fillColor:{view:r.fillColor,buffer:f},fillId:{view:r.fillId,buffer:u},fillElements:{view:r.fillElements,buffer:d}}},createResourceViews:function(e,t){var r=this.getElementsCtor(e);return{position:new Float32Array(2*e*t),offset:new Float32Array(2*e),color:new Float32Array(2*e*4),ud:new Float32Array(2*e*2),id:new Float32Array(2*e*1),elements:new r(4*e),fillPosition:new Float32Array(e*t),fillColor:new Float32Array(4*e),fillId:new Float32Array(1*e),fillElements:new r(3*e)}},getElementsCtor(e){var t=4*e*2>65536,r=this.context.regl.hasExtension("OES_element_index_uint");if(t&&!r)throw new Error("bufferSize is too big for Uint16Array, please enable OES_element_index_uint extension.");return t&&r?Uint32Array:Uint16Array},createAttributes:function(){var e=this.resources,t=this.state.cursor.dimensions,r=e.position,i=e.color,n=e.ud,o=e.id,s=e.offset,a=e.fillPosition,c=e.fillColor,f=e.fillId;return{line:{prevPosition:{buffer:r.buffer,offset:0,stride:l*t},currPosition:{buffer:r.buffer,offset:l*t*2,stride:l*t},nextPosition:{buffer:r.buffer,offset:l*t*4,stride:l*t},prevId:{buffer:o.buffer,offset:0,stride:l},currId:{buffer:o.buffer,offset:2*l,stride:l},nextId:{buffer:o.buffer,offset:4*l,stride:l},offset:s.buffer,ud:n.buffer,color:i.buffer},fill:{position:a.buffer,color:c.buffer,id:f.buffer}}},combineDrawArgs:function(e,t){var r=Object.assign({},e);return Object.keys(t).forEach(function(i){r[i]="uniforms"===i||"attributes"===i?Object.assign({},e[i],t[i]):t[i]}),r},createDrawCommand:function(e){var t=this.attributes,r=this.context.regl,i=this.resources,n=this.state,o={line:{aspect:function(e,t){return e.viewportWidth/e.viewportHeight},thickness:r.prop("thickness"),miterLimit:r.prop("miterLimit"),adjustProjectedThickness:function(e,t){return!0===t.adjustProjectedThickness?1:0}},fill:{}},l={enable:!1},f={enable:!0,face:"back"},u={enable:!0,equation:"add",func:{src:"src alpha",dst:"one minus src alpha"}},d={uniforms:{model:r.prop("model"),tint:r.prop("tint")}},v={vert:s.vert,frag:s.frag,uniforms:o.line,attributes:t.line,elements:i.elements.buffer,count:function(){return 6*n.cursor.quad},depth:l,cull:f,blend:u},m=e.drawLineArgs?this.combineDrawArgs(v,e.drawLineArgs):v,h={vert:c,frag:a,uniforms:o.fill,attributes:t.fill,elements:i.fillElements.buffer,count:function(){return 3*n.cursor.fillTri},depth:l,cull:f,blend:u},p=e.drawFillArgs?this.combineDrawArgs(h,e.drawFillArgs):h;if(n.is3d){m.vert="#define DIMENSIONS_3\n"+m.vert,m.frag="#define DIMENSIONS_3\n"+m.frag}var y=r(d),b=r(m),x=r(p);return function(e){return n.sync.vertex<n.cursor.vertex&&(this.syncResourceBuffers(),n.sync.vertex=n.cursor.vertex),y(e,function(){x(e),b(e)})}.bind(this)},syncResourceBuffers:function(){var e=this.resources,t=e.position,r=e.offset,i=e.color,n=e.ud,o=e.id,s=e.elements,a=e.fillPosition,c=e.fillColor,l=e.fillId,f=e.fillElements;t.buffer.subdata(t.view),r.buffer.subdata(r.view),i.buffer.subdata(i.view),n.buffer.subdata(n.view),o.buffer.subdata(o.view),s.buffer.subdata(s.view),a.buffer.subdata(a.view),c.buffer.subdata(c.view),l.buffer.subdata(l.view),f.buffer.subdata(f.view)},getContext:function(e){var t=this,r=this.state,i={},n=this["methods"+(e||"2d")],o=this,s=this.accessors;return f.forEach(function(e){var r=n[e]||o[e];r&&(i[e]=r.bind(t))}),u.forEach(function(e){var t=s[e];Object.defineProperty(i,e,t(r))}),i},resize:function(e){var t=this.state.cursor,r=this.resources,i=this.createResourceViews(e,t.dimensions);t.max=e,Object.keys(i).forEach(function(e){r[e].view=i[e],r[e].buffer({data:i[e]})})},reset:function(){var e=this.state,r=e.is3d,i=e.cursor,n=e.sync,o=e.style,s=e.transform;i.vertex=0,i.element=0,i.quad=0,i.fillVertex=0,i.fillElement=0,i.fillTri=0,n.vertex=0,o.lineWidth=1,o.color[0]=0,o.color[1]=0,o.color[2]=0,o.color[3]=1,s.isIdentity=!0,r?t.mat4.identity(s.matrix):t.mat2d.identity(s.matrix),e.activePath=null,e.pathCount=0,e.saveStack.length=0},destroy:function(){var e=this.resources;e.position.buffer.destroy(),e.offset.buffer.destroy(),e.color.buffer.destroy(),e.ud.buffer.destroy(),e.elements.buffer.destroy()},save:function(){var e=this.state,r=e.is3d,i=e.style,n=e.transform;e.saveStack.push({style:{lineWidth:i.lineWidth,color:i.color.slice()},transform:{isIdentity:n.isIdentity,matrix:r?t.mat4.clone(n.matrix):t.mat2d.clone(n.matrix)}})},restore:function(){var e=this.state,t=e.style,r=e.transform,i=e.saveStack.pop(),n=i.style,o=i.transform;t.lineWidth=n.lineWidth,t.color=n.color,r.isIdentity=o.isIdentity,r.matrix=o.matrix},beginPath:function(){var e=this.state,t=e.activePath,r=t?t.offset+t.count:0,i=e.scratchPath;i.reset(),i.offset=r,e.activePath=i},moveTo:function(e,r,i){var n=i||0,o=this.state,s=o.activePath,a=o.prevPosition,c=o.is3d,l=o.cursor,f=l.dimensions,u=++o.pathCount,d=o.style.color,v=.5*o.style.lineWidth,m=this.resources,h=m.position.view,p=m.offset.view,y=m.ud.view,b=m.id.view,x=m.color.view,w=this.transformInput(e,r,n),P=l.vertex*f*2,g=P+1,j=(l.vertex+1)*f*2,I=j+1;if(h[P]=h[P+f]=w[0],h[g]=h[g+f]=w[1],h[j]=h[j+f]=w[0],h[I]=h[I+f]=w[1],c){var S=P+2,_=j+2;h[S]=h[S+f]=w[2],h[_]=h[_+f]=w[2]}var C=2*l.vertex,k=2*(l.vertex+1);p[C+0]=v,p[C+1]=-v,p[k+0]=v,p[k+1]=-v;var A=2*l.vertex*2,M=A+1,E=2*(l.vertex+1)*2,T=E+1;y[A]=1,y[A+2]=-1,y[E]=1,y[E+2]=-1,y[M]=y[M+2]=0,y[T]=y[T+2]=0;var L=2*l.vertex,O=2*(l.vertex+1);b[L]=b[L+1]=u-1,b[O]=b[O+1]=u;var V=4*l.vertex*2,F=V+1,D=V+2,W=V+3,z=4*(l.vertex+1)*2,N=z+1,R=z+2,B=z+3;x[V]=x[V+4]=d[0],x[F]=x[F+4]=d[1],x[D]=x[D+4]=d[2],x[W]=x[W+4]=d[3],x[z]=x[z+4]=d[0],x[N]=x[N+4]=d[1],x[R]=x[R+4]=d[2],x[B]=x[B+4]=d[3],t.vec2.copy(a,w),s.addPoint(w),l.vertex+=2},lineTo:function(e,r,i,n){var o=i||0,s=this.state,a=s.activePath,c=s.prevPosition,l=s.is3d,f=s.cursor,u=f.dimensions,d=s.pathCount,v=s.style.color,m=.5*s.style.lineWidth,h=this.resources,p=h.position.view,y=h.offset.view,b=h.color.view,x=h.ud.view,w=h.id.view,P=h.elements.view,g=this.transformInput(e,r,o),j=t.vec2.distance(c,g),I=a.totalLength+=j,S=f.vertex*u*2,_=S+1;if(p[S]=p[S+u]=g[0],p[_]=p[_+u]=g[1],l){var C=S+2;p[C]=p[C+u]=g[2]}var k=2*f.vertex;y[k]=m,y[k+1]=-m;var A=2*(f.vertex-1)*2,M=A+1;x[A]=1,x[A+2]=-1,x[M]=x[M+2]=I;var E=2*f.vertex;w[E]=w[E+1]=d;var T=4*f.vertex*2,L=T+1,O=T+2,V=T+3;b[T]=b[T+4]=v[0],b[L]=b[L+4]=v[1],b[O]=b[O+4]=v[2],b[V]=b[V+4]=v[3];var F=6*f.quad,D=f.element,W=D+1,z=D+2,N=D+3;P[F+0]=D,P[F+1]=W,P[F+2]=z,P[F+3]=z,P[F+4]=W,P[F+5]=N,t.vec2.copy(c,g),a.addPoint(g),f.quad+=1,f.element+=2,f.vertex+=1},arc:function(e,t,r,i,n,o){for(var s=Math.abs(n-i),a=!0===o?-1:1,c=Math.ceil(s/(Math.PI/10)),l=0;l<c;l++){var f=i+l/(c-1)*s*a,u=e+Math.cos(f)*r,d=t+Math.sin(f)*r;0===l?this.moveTo(u,d):this.lineTo(u,d)}},closePath:function(){var e=this.state,t=e.activePath,r=e.cursor,i=r.dimensions,n=e.is3d,o=this.resources.position.view,s=(r.vertex-t.count)*i*2,a=o[s],c=o[s+1],l=n?o[s+2]:0;t.isClosed=!0,this.lineTo(a,c,l)},stroke:function(){var e=this.state,t=e.activePath,r=e.is3d,i=e.cursor,n=i.dimensions,o=e.pathCount,s=this.resources,a=s.position.view,c=s.offset.view,l=s.ud.view,f=s.id.view,u=s.color.view,d=i.vertex-t.count,v=i.vertex-1,m=i.vertex,h=v*n*2,p=h+1,y=m*n*2,b=y+1;if(a[y]=a[y+n]=a[h],a[b]=a[b+n]=a[p],r){var x=y+2,w=h+2;a[x]=a[x+n]=a[w]}var P=2*v,g=2*m;c[g]=c[P],c[g+1]=c[P+1];var j=2*v*2+1,I=2*m*2,S=I+1;l[I]=1,l[I+2]=-1,l[S]=l[S+2]=l[j];var _=2*i.vertex;f[_]=f[_+1]=o+1;var C=4*v*2,k=C+1,A=C+2,M=C+3,E=4*m*2,T=E+1,L=E+2,O=E+3;u[E]=u[E+4]=u[C],u[T]=u[T+4]=u[k],u[L]=u[L+4]=u[A],u[O]=u[O+4]=u[M],i.element+=6,i.vertex+=1,t.isClosed&&(this.copyPosition(d-1,v-1),this.copyPosition(m,d+1))},strokeRect:function(e,t,r,i){this.beginPath(),this.moveTo(e,t),this.lineTo(e+r,t),this.lineTo(e+r,t+i),this.lineTo(e,t+i),this.closePath(),this.stroke()},fill:function(){for(var e=this.state,t=e.cursor,i=e.activePath,n=e.pathCount,o=e.style.fillColor,s=this.resources,a=s.fillPosition.view,c=s.fillColor.view,l=s.fillId.view,f=s.fillElements.view,u=i.points,d=i.count+(i.isClosed?-1:0),v=new Float32Array(2*d),m=t.fillVertex,h=2*m,p=4*m,y=3*t.fillTri,b=0;b<d;b++){var x=u[b],w=2*b,P=w+1;a[h+w]=v[w]=x[0],a[h+P]=v[P]=x[1],l[m+b]=n;var g=4*b,j=g+1,I=g+2,S=g+3;c[p+g]=o[0],c[p+j]=o[1],c[p+I]=o[2],c[p+S]=o[3]}for(var _=r(v),C=_.length/3,k=0;k<C;k++){var A=3*k;f[y+A+0]=m+_[A+0],f[y+A+1]=m+_[A+1],f[y+A+2]=m+_[A+2]}t.fillVertex+=d,t.fillTri+=C},methods2d:{setTransform:function(e,r,i,n,o,s){var a=this.state.transform;t.mat2d.set(a.matrix,e,r,i,n,o,s),a.isIdentity=!1},translate:function(e,r){var i=this.state.transform,n=t.vec2.set(d,e,r);t.mat2d.translate(i.matrix,i.matrix,n),i.isIdentity=!1},scale:function(e,r){var i=this.state.transform,n=t.vec2.set(d,e,r);t.mat2d.scale(i.matrix,i.matrix,n),i.isIdentity=!1},rotate:function(e){var r=this.state.transform;t.mat2d.rotate(r.matrix,r.matrix,e),r.isIdentity=!1}},methods3d:{setTransform:function(e,r,i,n,o,s,a,c,l,f,u,d,v,m,h,p){var y=this.state.transform;t.mat4.set(y.matrix,e,r,i,n,o,s,a,c,l,f,u,d,v,m,h,p),y.isIdentity=!1},translate:function(e,r,i){var n=this.state.transform,o=t.vec3.set(d,e,r,i);t.mat4.translate(n.matrix,n.matrix,o),n.isIdentity=!1},scale:function(e,r,i){var n=this.state.transform,o=t.vec3.set(d,e,r,i);t.mat4.scale(n.matrix,n.matrix,o),n.isIdentity=!1},rotate:function(e,r){var i=this.state.transform;switch(r){case"x":t.mat4.rotateX(i.matrix,i.matrix,e);break;case"y":t.mat4.rotateY(i.matrix,i.matrix,e);break;case"z":t.mat4.rotateZ(i.matrix,i.matrix,e);break;default:t.mat4.rotate(i.matrix,i.matrix,e,r)}i.isIdentity=!1}},accessors:{lineWidth:function(e){return{get:function(){return e.style.lineWidth},set:function(t){return e.style.lineWidth=t,t}}},globalAlpha:function(e){return{get:function(){return e.style.color[3]},set:function(t){return e.style.color[3]=t,e.style.fillColor[3]=t,t}}},strokeStyle:function(e){return{get:function(){return e.style.strokeStyle},set:function(t){return o(e.style.color,t),e.style.strokeStyle=t,t}}},fillStyle:function(e){return{get:function(){return e.style.fillStyle},set:function(t){return o(e.style.fillColor,t),e.style.fillStyle=t,t}}}},transformInput:function(e,r,i){var n,o=i||0,s=this.state,a=s.is3d,c=s.activePath,l=s.transform;return a?(n=t.vec3.set(d,e,r,o),l.isIdentity||c.isClosed||t.vec3.transformMat4(n,n,l.matrix)):(n=t.vec2.set(d,e,r),l.isIdentity||c.isClosed||t.vec2.transformMat2d(n,n,l.matrix)),n},copyPosition:function(e,t){var r=this.state,i=r.is3d,n=r.cursor.dimensions,o=this.resources,s=o.position.view,a=o.id.view,c=e*n*2,l=c+1,f=t*n*2,u=f+1;if(s[c]=s[c+n]=s[f],s[l]=s[l+n]=s[u],i){var d=c+2,v=f+2;s[d]=s[d+n]=s[v]}var m=2*e,h=2*t;a[m]=a[m+1]=a[h]}}),e.LineBuilder=v,e.line=s,Object.defineProperty(e,"__esModule",{value:!0})});
